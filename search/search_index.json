{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TLS 1.3 Tamarin Model","text":"<p>Danger</p> <p>This site is still work in progress. Sections might not be finished or contain all relevant details.</p> <p>This site serves a description of the Tamarin Prover TLS 1.3 model. The model has already undergone several revisions of TLS and is now at the level of RFC 8446 (with a few restrictions). You can find a brief overview of the models history also including some forks and variants of the model in the history section. This documentation is based on the documentation by Sam Scott which can be found here. The documentation is split into multiple sections:</p> <ul> <li> <p> Model</p> <p>The model itself containing all necessary Multiset-Rewriting-Rules</p> <p> More</p> </li> <li> <p> Lemmas</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> More</p> </li> <li> <p> History</p> <p>Brief overview of older revisions of the model and some forks and variants.  More</p> </li> <li> <p> RFC Mapping</p> <p>Annotated RFC 8446 to explain mapping to the model.  More</p> </li> </ul> <ul> <li> 1.Introduction</li> <li> 1.1.Conventions and Terminology</li> <li> 1.2.Major Differences from TLS 1.2</li> <li> 1.3.Updates Affecting TLS 1.2</li> <li> 2.Protocol Overview</li> <li> 2.1.Incorrect DHE Share</li> <li> 2.2.Resumption and Pre-Shared Key (PSK)</li> <li> 2.3.0-RTT Data</li> <li> 3.Presentation Language</li> <li> 3.1.Basic Block Size</li> <li> 3.2.Miscellaneous</li> <li> 3.3.Numbers</li> <li> 3.4.Vectors</li> <li> 3.5.Enumerateds</li> <li> 3.6.Constructed Types</li> <li> 3.7.Constants</li> <li> 3.8.Variants</li> <li> 4.Handshake Protocol</li> <li> 4.1.Key Exchange Messages</li> <li> 4.1.1.Cryptographic Negotiation</li> <li> 4.1.2.Client Hello</li> <li> 4.1.3.Server Hello</li> <li> 4.1.4.Hello Retry Request</li> <li> 4.2.Extensions</li> <li> 4.2.1.Supported Versions</li> <li> 4.2.2.Cookie</li> <li> 4.2.3.Signature Algorithms</li> <li> 4.2.4.Certificate Authorities</li> <li> 4.2.5.OID Filters</li> <li> 4.2.6.Post-Handshake Client Authentication</li> <li> 4.2.7.Supported Groups</li> <li> 4.2.8.Key Share</li> <li> 4.2.8.1.Diffie-Hellman Parameters</li> <li> 4.2.8.2.ECDHE Parameters</li> <li> 4.2.9.Pre-Shared Key Exchange Modes</li> <li> 4.2.10.Early Data Indication</li> <li> 4.2.11.Pre-Shared Key Extension</li> <li> 4.2.11.1.Ticket Age</li> <li> 4.2.11.2.PSK Binder</li> <li> 4.2.11.3.Processing Order</li> <li> 4.3.Server Parameters</li> <li> 4.3.1.Encrypted Extensions</li> <li> 4.3.2.Certificate Request</li> <li> 4.4.Authentication Messages</li> <li> 4.4.1.The Transcript Hash</li> <li> 4.4.2.Certificate</li> <li> 4.4.2.1.OCSP Status and SCT Extensions</li> <li> 4.4.2.2.Server Certificate Selection</li> <li> 4.4.2.3.Client Certificate Selection</li> <li> 4.4.2.4.Receiving a Certificate Message</li> <li> 4.4.3.Certificate Verify</li> <li> 4.4.4.Finished</li> <li> 4.5.End of Early Data</li> <li> 4.6.Post-Handshake Messages</li> <li> 4.6.1.New Session Ticket Message</li> <li> 4.6.2.Post-Handshake Authentication</li> <li> 4.6.3.Key and Initialization Vector Update</li> <li> 5.Record Protocol</li> <li> 5.1.Record Layer</li> <li> 5.2.Record Payload Protection</li> <li> 5.3.Per-Record Nonce</li> <li> 5.4.Record Padding</li> <li> 5.5.Limits on Key Usage</li> <li> 6.Alert Protocol</li> <li> 6.1.Closure Alerts</li> <li> 6.2.Error Alerts</li> <li> 7.Cryptographic Computations</li> <li> 7.1.Key Schedule</li> <li> 7.2.Updating Traffic Secrets</li> <li> 7.3.Traffic Key Calculation</li> <li> 7.4.(EC)DHE Shared Secret Calculation</li> <li> 7.4.1.Finite Field Diffie-Hellman</li> <li> 7.4.2.Elliptic Curve Diffie-Hellman</li> <li> 7.5.Exporters</li> <li> 8.0-RTT and Anti-Replay</li> <li> 8.1.Single-Use Tickets</li> <li> 8.2.Client Hello Recording</li> <li> 8.3.Freshness Checks</li> <li> 9.Compliance Requirements</li> <li> 9.1.Mandatory-to-Implement Cipher Suites</li> <li> 9.2.Mandatory-to-Implement Extensions</li> <li> 9.3.Protocol Invariants</li> <li> 10.Security Considerations</li> <li> 11.IANA Considerations</li> <li> 12.References</li> <li> 12.1.Normative References</li> <li> 12.2.Informative References</li> <li> A.State Machine</li> <li> A.1.Client</li> <li> A.2.Server</li> <li> B.Protocol Data Structures and Constant Values</li> <li> B.1.Record Layer</li> <li> B.2.Alert Messages</li> <li> B.3.Handshake Protocol</li> <li> B.3.1.Key Exchange Messages</li> <li> B.3.1.1.Version Extension</li> <li> B.3.1.2.Cookie Extension</li> <li> B.3.1.3.Signature Algorithm Extension</li> <li> B.3.1.4.Supported Groups Extension</li> <li> B.3.2.Server Parameters Messages</li> <li> B.3.3.Authentication Messages</li> <li> B.3.4.Ticket Establishment</li> <li> B.3.5.Updating Keys</li> <li> B.4.Cipher Suites</li> <li> C.Implementation Notes</li> <li> C.1.Random Number Generation and Seeding</li> <li> C.2.Certificates and Authentication</li> <li> C.3.Implementation Pitfalls</li> <li> C.4.Client Tracking Prevention</li> <li> C.5.Unauthenticated Operation</li> <li> D.Backward Compatibility</li> <li> D.1.Negotiating with an Older Server</li> <li> D.2.Negotiating with an Older Client</li> <li> D.3.0-RTT Backward Compatibility</li> <li> D.4.Middlebox Compatibility Mode</li> <li> D.5.Security Restrictions Related to Backward Compatibility</li> <li> E.Overview of Security Properties</li> <li> E.1.Handshake</li> <li> E.1.1.Key Derivation and HKDF</li> <li> E.1.2.Client Authentication</li> <li> E.1.3.0-RTT</li> <li> E.1.4.Exporter Independence</li> <li> E.1.5.Post-Compromise Security</li> <li> E.1.6.External References</li> <li> E.2.Record Layer</li> <li> E.2.1.External References</li> <li> E.3.Traffic Analysis</li> <li> E.4.Side-Channel Attacks</li> <li> E.5.Replay Attacks on 0-RTT</li> <li> E.5.1.Replay and Exporters</li> <li> E.6.PSK Identity Exposure</li> <li> E.7.Sharing PSKs</li> <li> E.8.Attacks on Static RSA</li> </ul>"},{"location":"RFC%20Mapping/","title":"RFC Mapping","text":"<p>This section of the models documentation is dedicated to users who are familiar with the RFC 8446 and want to see how the model maps to the standard. Therefor each section of the RFC is mentioned in the following subsections and mapped to the model.</p>"},{"location":"RFC%20Mapping/1.%20Introduction/","title":"1. Introduction","text":"RFC 8446<pre><code>The primary goal of TLS is to provide a secure channel between two\ncommunicating peers; the only requirement from the underlying\ntransport is a reliable, in-order data stream.  Specifically, the\nsecure channel should provide the following properties:\n\n-  Authentication: The server side of the channel is always\n    authenticated; the client side is optionally authenticated.\n    Authentication can happen via asymmetric cryptography (e.g., RSA\n    [RSA], the Elliptic Curve Digital Signature Algorithm (ECDSA)\n    [ECDSA], or the Edwards-Curve Digital Signature Algorithm (EdDSA)\n    [RFC8032]) or a symmetric pre-shared key (PSK).\n\n-  Confidentiality: Data sent over the channel after establishment is\n    only visible to the endpoints.  TLS does not hide the length of\n    the data it transmits, though endpoints are able to pad TLS\n    records in order to obscure lengths and improve protection against\n    traffic analysis techniques.\n\n-  Integrity: Data sent over the channel after establishment cannot\n    be modified by attackers without detection.\n\nThese properties should be true even in the face of an attacker who\nhas complete control of the network, as described in [RFC3552].  See\nAppendix E for a more complete statement of the relevant security\nproperties.\n</code></pre> <p>As the introduction section of the RFC mentions, the protocol should provide a secure channel between two communicating peers. The two peers are modelled as <code>server</code> and <code>client</code>.</p> RFC 8446<pre><code>TLS consists of two primary components:\n\n-  A handshake protocol (Section 4) that authenticates the\n    communicating parties, negotiates cryptographic modes and\n    parameters, and establishes shared keying material.  The handshake\n    protocol is designed to resist tampering; an active attacker\n    should not be able to force the peers to negotiate different\n    parameters than they would if the connection were not under\n    attack.\n\n-  A record protocol (Section 5) that uses the parameters established\n    by the handshake protocol to protect traffic between the\n    communicating peers.  The record protocol divides traffic up into\n    a series of records, each of which is independently protected\n    using the traffic keys.\n</code></pre> <p>The model focuses on the Handshake proctol in section 4. Nevertheless there is a highly abstract version of the record layer modeled and it is explained in section 5.1.</p>"},{"location":"RFC%20Mapping/1.%20Introduction/01_01_conventions_and_terminology/","title":"1.1. Conventions and Terminology","text":"RFC 8446<pre><code>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n\"OPTIONAL\" in this document are to be interpreted as described in\nBCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\ncapitals, as shown here.\n\nThe following terms are used:\n\nclient:  The endpoint initiating the TLS connection.\n\nconnection:  A transport-layer connection between two endpoints.\n\nendpoint:  Either the client or server of the connection.\n\nhandshake:  An initial negotiation between client and server that\n    establishes the parameters of their subsequent interactions\n    within TLS.\n\npeer:  An endpoint.  When discussing a particular endpoint, \"peer\"\n    refers to the endpoint that is not the primary subject of\n    discussion.\n\nreceiver:  An endpoint that is receiving records.\n\nsender:  An endpoint that is transmitting records.\n\nserver:  The endpoint that did not initiate the TLS connection.\n</code></pre> <p>The defined conventions and terminology are also valid for the model. The terms <code>client</code> and <code>server</code> are frequently used in the context of the model.</p>"},{"location":"RFC%20Mapping/1.%20Introduction/01_02_major_differences_from_tls_1_2/","title":"1.2. Major Differences from TLS 1.2","text":"<p>Since there is no model code related to TLS 1.2 this section is not covered.</p>"},{"location":"RFC%20Mapping/1.%20Introduction/01_03_updated_affecting_tls_1_2/","title":"1.3. Updates Affecting TLS 1.2","text":"<p>Since there is no model code related to TLS 1.2 this section is not covered.</p>"},{"location":"RFC%20Mapping/10.%20Security%20Considerations/","title":"10. Security Considerations","text":"<p>The security considerations are related to real TLS deployments and therefor not included in the symbolic model for now.</p>"},{"location":"RFC%20Mapping/11.%20IANA%20Considerations/","title":"11. References","text":"<p>This section contains no information relevant to the protocol model.</p>"},{"location":"RFC%20Mapping/12.%20References/","title":"12. References","text":"<p>This section contains no information relevant to the protocol model.</p>"},{"location":"RFC%20Mapping/2.%20Protocol%20Overview/","title":"2. Protocol Overview","text":"RFC 8446<pre><code>TLS supports three basic key exchange modes:\n\n-  (EC)DHE (Diffie-Hellman over either finite fields or elliptic\n   curves)\n\n-  PSK-only\n\n-  PSK with (EC)DHE\n</code></pre> <p>The Tamarin TLS model contains all three handshake types. The libraries <code>src/client.splib</code> and <code>src/server.splib</code> contain all (EC)DHE related multiset rewriting rules. The libraries <code>src/clientPsk.splib</code> and <code>src/serverPsk.splib</code> are related to the PSK-only and PSK with (EC)DHE mode.</p> RFC 8446<pre><code>   Figure 1 below shows the basic full TLS handshake:\n\n       Client                                           Server\n\nKey  ^ ClientHello\nExch | + key_share*\n     | + signature_algorithms*\n     | + psk_key_exchange_modes*\n     v + pre_shared_key*       --------&gt;\n                                                  ServerHello  ^ Key\n                                                 + key_share*  | Exch\n                                            + pre_shared_key*  v\n                                        {EncryptedExtensions}  ^  Server\n                                        {CertificateRequest*}  v  Params\n                                               {Certificate*}  ^\n                                         {CertificateVerify*}  | Auth\n                                                   {Finished}  v\n                               &lt;--------  [Application Data*]\n     ^ {Certificate*}\nAuth | {CertificateVerify*}\n     v {Finished}              --------&gt;\n       [Application Data]      &lt;-------&gt;  [Application Data]\n</code></pre> <p></p> <p></p>"},{"location":"RFC%20Mapping/2.%20Protocol%20Overview/02_01_incorrect_dhe_share/","title":"2.1. Incorrect DHE Share","text":"RFC 8446<pre><code>If the client has not provided a sufficient \"key_share\" extension\n(e.g., it includes only DHE or ECDHE groups unacceptable to or\nunsupported by the server), the server corrects the mismatch with a\nHelloRetryRequest and the client needs to restart the handshake with\nan appropriate \"key_share\" extension, as shown in Figure 2.  If no\ncommon cryptographic parameters can be negotiated, the server MUST\nabort the handshake with an appropriate alert.\n\n      Client                                               Server\n\n      ClientHello\n      + key_share             --------&gt;\n                                                HelloRetryRequest\n                              &lt;--------               + key_share\n      ClientHello\n      + key_share             --------&gt;\n                                                      ServerHello\n                                                      + key_share\n                                             {EncryptedExtensions}\n                                             {CertificateRequest*}\n                                                   {Certificate*}\n                                             {CertificateVerify*}\n                                                      {Finished}\n                              &lt;--------       [Application Data*]\n      {Certificate*}\n      {CertificateVerify*}\n      {Finished}              --------&gt;\n      [Application Data]      &lt;-------&gt;        [Application Data]\n\n            Figure 2: Message Flow for a Full Handshake with\n                        Mismatched Parameters\n\nNote: The handshake transcript incorporates the initial\nClientHello/HelloRetryRequest exchange; it is not reset with the\nnew ClientHello.\n\nTLS also allows several optimized variants of the basic handshake, as\ndescribed in the following sections.\n</code></pre> <p>The <code>HelloRetryRequest</code> mentioned in section 2.1. of the draft is actually a special <code>ServerHello</code> message which is defined in detail in section 4.1.3. of the RFC. You can find details of the modelled HelloRetryRequest here.</p>"},{"location":"RFC%20Mapping/2.%20Protocol%20Overview/02_02_resumption_and_pre_shared_key/","title":"2.2. Resumption and Pre-Shared Key (PSK)","text":"RFC 8446<pre><code>Although TLS PSKs can be established out of band, PSKs can also be\nestablished in a previous connection and then used to establish a new\nconnection (\"session resumption\" or \"resuming\" with a PSK).  Once a\nhandshake has completed, the server can send the client a PSK\nidentity that corresponds to a unique key derived from the initial\nhandshake (see Section 4.6.1).  The client can then use that PSK\nidentity in future handshakes to negotiate the use of the associated\nPSK.  If the server accepts the PSK, then the security context of the\nnew connection is cryptographically tied to the original connection\nand the key derived from the initial handshake is used to bootstrap\nthe cryptographic state instead of a full handshake.  In TLS 1.2 and\nbelow, this functionality was provided by \"session IDs\" and \"session\ntickets\" [RFC5077].  Both mechanisms are obsoleted in TLS 1.3.\n\nPSKs can be used with (EC)DHE key exchange in order to provide\nforward secrecy in combination with shared keys, or can be used\nalone, at the cost of losing forward secrecy for the application\ndata.\n</code></pre> RFC 8446<pre><code>Note:  When using an out-of-band provisioned pre-shared secret, a\n    critical consideration is using sufficient entropy during the key\n    generation, as discussed in [RFC4086].  Deriving a shared secret\n    from a password or other low-entropy sources is not secure.  A\n    low-entropy secret, or password, is subject to dictionary attacks\n    based on the PSK binder.  The specified PSK authentication is not\n    a strong password-based authenticated key exchange even when used\n    with Diffie-Hellman key establishment.  Specifically, it does not\n    prevent an attacker that can observe the handshake from performing\n    a brute-force attack on the password/pre-shared key.\n</code></pre> <p>This note on out-of-band provisioned pre-shared secret is not implemented in the model for now. Cryprographic primitives are considered perfect. Non the less one could implement sufficient entropy by modelling the assumed problems it has. Then one could analyse the consequences of this.</p>"},{"location":"RFC%20Mapping/2.%20Protocol%20Overview/02_03_0_rtt_data/","title":"2.3. 0-RTT Data","text":"RFC 8446<pre><code>When clients and servers share a PSK (either obtained externally or\nvia a previous handshake), TLS 1.3 allows clients to send data on the\nfirst flight (\"early data\").  The client uses the PSK to authenticate\nthe server and to encrypt the early data.\n\nAs shown in Figure 4, the 0-RTT data is just added to the 1-RTT\nhandshake in the first flight.  The rest of the handshake uses the\nsame messages as for a 1-RTT handshake with PSK resumption.\n\n        Client                                               Server\n\n        ClientHello\n        + early_data\n        + key_share*\n        + psk_key_exchange_modes\n        + pre_shared_key\n        (Application Data*)     --------&gt;\n                                                        ServerHello\n                                                + pre_shared_key\n                                                    + key_share*\n                                            {EncryptedExtensions}\n                                                    + early_data*\n                                                        {Finished}\n                                &lt;--------       [Application Data*]\n        (EndOfEarlyData)\n        {Finished}              --------&gt;\n        [Application Data]      &lt;-------&gt;        [Application Data]\n\n            +  Indicates noteworthy extensions sent in the\n                previously noted message.\n\n            *  Indicates optional or situation-dependent\n                messages/extensions that are not always sent.\n\n            () Indicates messages protected using keys\n                derived from a client_early_traffic_secret.\n\n            {} Indicates messages protected using keys\n                derived from a [sender]_handshake_traffic_secret.\n\n            [] Indicates messages protected using keys\n                derived from [sender]_application_traffic_secret_N.\n\n            Figure 4: Message Flow for a 0-RTT Handshake\n</code></pre>"},{"location":"RFC%20Mapping/3.%20Presentation%20Language/","title":"3. Presentation Language","text":"<p>Not all defined sections of the presentation language are relevant for the Tamarin model. Only the relevant parts are described in detail in the following subsections.# 3.7. Constants.</p>"},{"location":"RFC%20Mapping/3.%20Presentation%20Language/03_05_enumerateds/","title":"3.5. Enumerateds","text":"<pre><code>An additional sparse data type, called \"enum\" or \"enumerated\", is\navailable.  Each definition is a different type.  Only enumerateds of\nthe same type may be assigned or compared.  Every element of an\nenumerated must be assigned a value, as demonstrated in the following\nexample.  Since the elements of the enumerated are not ordered, they\ncan be assigned any unique value, in any order.\n\n    enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;\n\nFuture extensions or additions to the protocol may define new values.\nImplementations need to be able to parse and ignore unknown values\nunless the definition of the field states otherwise.\n\nAn enumerated occupies as much space in the byte stream as would its\nmaximal defined ordinal value.  The following definition would cause\none byte to be used to carry fields of type Color.\n\n    enum { red(3), blue(5), white(7) } Color;\n\nOne may optionally specify a value without its associated tag to\nforce the width definition without defining a superfluous element.\n\nIn the following example, Taste will consume two bytes in the data\nstream but can only assume the values 1, 2, or 4 in the current\nversion of the protocol.\n\n    enum { sweet(1), sour(2), bitter(4), (32000) } Taste;\n\nThe names of the elements of an enumeration are scoped within the\ndefined type.  In the first example, a fully qualified reference to\nthe second element of the enumeration would be Color.blue.  Such\nqualification is not required if the target of the assignment is well\nspecified.\n\n    Color color = Color.blue;     /* overspecified, legal */\n    Color color = blue;           /* correct, type implicit */\n\nThe names assigned to enumerateds do not need to be unique.  The\nnumerical value can describe a range over which the same name\napplies.  The value includes the minimum and maximum inclusive values\nin that range, separated by two period characters.  This is\nprincipally useful for reserving regions of the space.\n\n    enum { sad(0), meh(1..254), happy(255) } Mood;\n</code></pre> <p>There is no enumeration type in Tamarin but the model uses macros to set a global constant for each enumeration value. An example for this can be found in the Handshake Protocol section.</p>"},{"location":"RFC%20Mapping/3.%20Presentation%20Language/03_06_constructed_types/","title":"3.6. Constructed Types","text":"<p>The typing for constructed types is not relevant for a symbolic model.</p>"},{"location":"RFC%20Mapping/3.%20Presentation%20Language/03_07_constants/","title":"3.7. Constants","text":"<pre><code>Fields and variables may be assigned a fixed value using \"=\", as in:\n\n    struct {\n        T1 f1 = 8;  /* T.f1 must always be 8 */\n        T2 f2;\n    } T;\n</code></pre> <p>Constants are modelled through integrated Tamarin macros and can be found in the <code>macros.splib</code>.</p>"},{"location":"RFC%20Mapping/3.%20Presentation%20Language/03_08_variants/","title":"3.8. Variants","text":"RFC 8446<pre><code>Defined structures may have variants based on some knowledge that is\navailable within the environment.  The selector must be an enumerated\ntype that defines the possible variants the structure defines.  Each\narm of the select (below) specifies the type of that variant's field\nand an optional field label.  The mechanism by which the variant is\nselected at runtime is not prescribed by the presentation language.\n\n    struct {\n        T1 f1;\n        T2 f2;\n        ....\n        Tn fn;\n        select (E) {\n            case e1: Te1 [[fe1]];\n            case e2: Te2 [[fe2]];\n            ....\n            case en: Ten [[fen]];\n        };\n    } Tv;\n\nFor example:\n\n    enum { apple(0), orange(1) } VariantTag;\n\n    struct {\n        uint16 number;\n        opaque string&lt;0..10&gt;; /* variable length */\n    } V1;\n\n    struct {\n        uint32 number;\n        opaque string[10];    /* fixed length */\n    } V2;\n\n    struct {\n        VariantTag type;\n        select (VariantRecord.type) {\n            case apple:  V1;\n            case orange: V2;\n        };\n    } VariantRecord;\n</code></pre> <p>Variants structures are modelled using integrated Tamarin macros which are then nested inside each other. Taken the given example the macros in Tamarin could look like this. Tamarin<pre><code>VariantRecord(type, content) = &lt;type, content&gt;\nApple(number, string) = VariantRecord('0', &lt;number, string&gt;)\nOrange(number, string) = VariantRecord('1', &lt;number, string&gt;)\n</code></pre></p>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/","title":"4. Handshake Protocol","text":"<p>The handshake protocol consists of several message types. Each message type is identified by a unique number. All enumeration values (relevant for the model) are defined as macros containing a string with the message identifier in the <code>macros.splib</code>.</p> <pre><code>enum {\n    client_hello(1),\n    server_hello(2),\n    new_session_ticket(4),\n    end_of_early_data(5),\n    encrypted_extensions(8),\n    certificate(11),\n    certificate_request(13),\n    certificate_verify(15),\n    finished(20),\n    key_update(24),\n    message_hash(254),\n    (255)\n} HandshakeType;\n</code></pre> <pre><code>HandshakeMessageTypeClientHello() = '1',\nHandshakeMessageTypeServerHello() = '2',\nHandshakeMessageTypeNewSessionTicket() = '4',\nHandshakeMessageTypeEncryptedExtensions() = '8',\nHandshakeMessageTypeCertificate() = '11',\nHandshakeMessageTypeCertificateRequest() = '13',\nHandshakeMessageTypeCertificateVerify() = '15',\nHandshakeMessageTypeFinished() = '20',\nHandshakeMessageTypeKeyUpdate() = '24',\n</code></pre> <p>Each message type has a different content. Therefor the general handshake message structure is modelled using a macro. The length of the message is not modelled because in symbolic modelling we use abstract terms for messages. Concrete representation of messages (e.g. length, bit-structure or padding) are not validated.</p> <pre><code>struct {\n    HandshakeType msg_type;    /* handshake type */\n    uint24 length;             /* remaining bytes in message */\n    select (Handshake.msg_type) {\n        case client_hello:          ClientHello;\n        case server_hello:          ServerHello;\n        case end_of_early_data:     EndOfEarlyData;\n        case encrypted_extensions:  EncryptedExtensions;\n        case certificate_request:   CertificateRequest;\n        case certificate:           Certificate;\n        case certificate_verify:    CertificateVerify;\n        case finished:              Finished;\n        case new_session_ticket:    NewSessionTicket;\n        case key_update:            KeyUpdate;\n    };\n} Handshake;\n</code></pre> <pre><code>Handshake(msg_type, content) = &lt;msg_type, content&gt;,\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_01_key_exchange_message/","title":"4.1. Key Exchange Messages","text":""},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_01_key_exchange_message/#412-client-hello","title":"4.1.2 Client Hello","text":"<pre><code>struct {\n    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */\n    Random random;\n    opaque legacy_session_id&lt;0..32&gt;;\n    CipherSuite cipher_suites&lt;2..2^16-2&gt;;\n    opaque legacy_compression_methods&lt;1..2^8-1&gt;;\n    Extension extensions&lt;8..2^16-1&gt;;\n} ClientHello;\n</code></pre> <pre><code>LegacyVersion() = '0x0303',\nClientHello(\n    random,\n    legacy_session_id,\n    cipher_suites,\n    legacy_compression_methods,\n    extensions\n) = Handshake(\n    HandshakeMessageTypeClientHello(),\n    &lt;LegacyVersion(),\n    random,\n    legacy_session_id,\n    cipher_suites,\n    legacy_compression_methods,\n    extensions&gt;\n),\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_01_key_exchange_message/#413-server-hello","title":"4.1.3 Server Hello","text":""},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_01_key_exchange_message/#414-hello-retry-request","title":"4.1.4 Hello Retry Request","text":""},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/","title":"4.2. Extensions","text":"<p>Key exchange messages like the Client Hello or Server Hello support an optional list of extensions. Each extension is identified by a unique number. All enumeration values (relevant for the model) are directly encoded in the extension <code>macros.splib</code>. The code belows shows an example for the Support Version extension.</p> RFC 8446<pre><code>enum {\n    server_name(0),                             /* RFC 6066 */\n    max_fragment_length(1),                     /* RFC 6066 */\n    status_request(5),                          /* RFC 6066 */\n    supported_groups(10),                       /* RFC 8422, 7919 */\n    signature_algorithms(13),                   /* RFC 8446 */\n    use_srtp(14),                               /* RFC 5764 */\n    heartbeat(15),                              /* RFC 6520 */\n    application_layer_protocol_negotiation(16), /* RFC 7301 */\n    signed_certificate_timestamp(18),           /* RFC 6962 */\n    client_certificate_type(19),                /* RFC 7250 */\n    server_certificate_type(20),                /* RFC 7250 */\n    padding(21),                                /* RFC 7685 */\n    pre_shared_key(41),                         /* RFC 8446 */\n    early_data(42),                             /* RFC 8446 */\n    supported_versions(43),                     /* RFC 8446 */\n    cookie(44),                                 /* RFC 8446 */\n    psk_key_exchange_modes(45),                 /* RFC 8446 */\n    certificate_authorities(47),                /* RFC 8446 */\n    oid_filters(48),                            /* RFC 8446 */\n    post_handshake_auth(49),                    /* RFC 8446 */\n    signature_algorithms_cert(50),              /* RFC 8446 */\n    key_share(51),                              /* RFC 8446 */\n    (65535)\n} ExtensionType;\n</code></pre> src/model/macros.splib<pre><code>ProtocolVersion() = '0x0303',\nExtensionSupportedVersions() = Extension('43', ProtocolVersion()),\n</code></pre> <p>The structure of an extension is based on the extension itself. Therefor the extension wrapper struct just contains the type and the extension data.</p> RFC 8446<pre><code>struct {\n    ExtensionType extension_type;\n    opaque extension_data&lt;0..2^16-1&gt;;\n} Extension;\n</code></pre> src/model/macros.splib<pre><code>Extension(extension_type, extension_data) = &lt;extension_type, extension_data&gt;,\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#421-supported-versions","title":"4.2.1. Supported Versions","text":"<p>Downgrade protection and therefor multiple supported versions are not implemented in the model by now. Nevertheless the model includes the extension itself but does not negotiate the supported version. It is assumed that both peers only support one version, which is the same.</p> <pre><code>uint16 ProtocolVersion;\nstruct {\n    select (Handshake.msg_type) {\n        case client_hello:\n            ProtocolVersion versions&lt;2..254&gt;;\n\n        case server_hello: /* and HelloRetryRequest */\n            ProtocolVersion selected_version;\n    };\n} SupportedVersions;\n</code></pre> <pre><code>ProtocolVersion() = '0x0304',\nExtensionSupportedVersions() = Extension('43', ProtocolVersion()),\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#422-cookie","title":"4.2.2. Cookie","text":"<p>This extension is currently not covered in the model.</p>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#423-signature-algorithms","title":"4.2.3. Signature Algorithms","text":"<p>The client uses the \"signature_algorithms\" extension to indicate to the server which signature algorithms may be used in digital signatures. Clients which desire the server to authenticate itself via a certificate MUST send this extension. Due to the assumption of \"perfect crypto\" much of this extension is irrelevant. The offered list is simply modelled as some public knowledge parameter and validate the integrity of those algorithms in the transcript.</p> RFC 8446<pre><code>TLS 1.3 provides two extensions for indicating which signature\nalgorithms may be used in digital signatures.  The\n\"signature_algorithms_cert\" extension applies to signatures in\ncertificates, and the \"signature_algorithms\" extension, which\noriginally appeared in TLS 1.2, applies to signatures in\nCertificateVerify messages.  The keys found in certificates MUST also\nbe of appropriate type for the signature algorithms they are used\nwith.  This is a particular issue for RSA keys and PSS signatures, as\ndescribed below.  If no \"signature_algorithms_cert\" extension is\npresent, then the \"signature_algorithms\" extension also applies to\nsignatures appearing in certificates.  Clients which desire the\nserver to authenticate itself via a certificate MUST send the\n\"signature_algorithms\" extension.  If a server is authenticating via\na certificate and the client has not sent a \"signature_algorithms\"\nextension, then the server MUST abort the handshake with a\n\"missing_extension\" alert (see Section 9.2).\n\n    struct {\n        SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;\n    } SignatureSchemeList;\n</code></pre> src/model/macros.splib<pre><code>ExtensionSignatureSchemeList(supported_signature_algorithms) = Extension('13', supported_signature_algorithms)\n</code></pre> src/model/serverPsk.splib<pre><code>extensions = &lt;\n    ExtensionSignatureSchemeList($sig_algs),\n    &lt;'41', '0'&gt;,\n    p_edi\n&gt;\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#424-certificate-algorithms","title":"4.2.4. Certificate Algorithms","text":"<p>The certificate authorities extension is not modelled at the moment.</p>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#425-oid-filters","title":"4.2.5. OID Filters","text":"<p>The OID filters extension is not modelled at the moment.</p>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#426-post-handshake-client-authentication","title":"4.2.6. Post-Handshake Client Authentication","text":"<p>The Post-Handshake Client Authentication is not modelled at the moment.</p>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#427-supported-groups","title":"4.2.7. Supported Groups","text":"<p>When sent by the client, the \"supported_groups\" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred. The model only support the client sending two (distinct) groups. However, <code>$g1</code> and <code>$g2</code> are free to be any value, so any two client hello messages may have no overlapping groups. You can find more information about this in section 4.1.4.</p> <p>As of TLS 1.3, servers are permitted to send the \"supported_groups\" extension to the client. If the server has a group it prefers to the ones in the \"key_share\" extension but is still willing to accept the ClientHello, it SHOULD send \"supported_groups\" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client. Clients MUST NOT act upon any information found in \"supported_groups\" prior to successful completion of the handshake, but MAY use the information learned from a successfully completed handshake to change what groups they use in their \"key_share\" extension in subsequent connections. This behavior is not modelled at the moment.</p> RFC 8446<pre><code>When sent by the client, the \"supported_groups\" extension indicates\nthe named groups which the client supports for key exchange, ordered\nfrom most preferred to least preferred.\n\nNote: In versions of TLS prior to TLS 1.3, this extension was named\n\"elliptic_curves\" and only contained elliptic curve groups.  See\n[RFC8422] and [RFC7919].  This extension was also used to negotiate\nECDSA curves.  Signature algorithms are now negotiated independently\n(see Section 4.2.3).\n\nThe \"extension_data\" field of this extension contains a\n\"NamedGroupList\" value:\n\n    enum {\n\n        /* Elliptic Curve Groups (ECDHE) */\n        secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),\n        x25519(0x001D), x448(0x001E),\n\n        /* Finite Field Groups (DHE) */\n        ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),\n        ffdhe6144(0x0103), ffdhe8192(0x0104),\n\n        /* Reserved Code Points */\n        ffdhe_private_use(0x01FC..0x01FF),\n        ecdhe_private_use(0xFE00..0xFEFF),\n        (0xFFFF)\n    } NamedGroup;\n\n    struct {\n        NamedGroup named_group_list&lt;2..2^16-1&gt;;\n    } NamedGroupList;\n\nElliptic Curve Groups (ECDHE):  Indicates support for the\n    corresponding named curve, defined in either FIPS 186-4 [DSS] or\n    [RFC7748].  Values 0xFE00 through 0xFEFF are reserved for\n    Private Use [RFC8126].\n\nFinite Field Groups (DHE):  Indicates support for the corresponding\n    finite field group, defined in [RFC7919].  Values 0x01FC through\n    0x01FF are reserved for Private Use.\n\nItems in named_group_list are ordered according to the sender's\npreferences (most preferred choice first).\n\nAs of TLS 1.3, servers are permitted to send the \"supported_groups\"\nextension to the client.  Clients MUST NOT act upon any information\nfound in \"supported_groups\" prior to successful completion of the\nhandshake but MAY use the information learned from a successfully\ncompleted handshake to change what groups they use in their\n\"key_share\" extension in subsequent connections.  If the server has a\ngroup it prefers to the ones in the \"key_share\" extension but is\nstill willing to accept the ClientHello, it SHOULD send\n\"supported_groups\" to update the client's view of its preferences;\nthis extension SHOULD contain all groups the server supports,\nregardless of whether they are currently supported by the client.\n</code></pre> src/model/macros.splib<pre><code>ExtensionNamedGroupdList(supported_groups) = Extension('10', supported_groups),\n</code></pre> src/model/client.splib<pre><code>supported_groups = &lt;$g1, $g2&gt;\nextensions = &lt;\n    ExtensionSupportedVersions(),\n    ExtensionNamedGroupdList(supported_groups),\n    ExtensionSignatureSchemeList($sig_algs),\n    ExtensionKeyShare(KeyShareEntry($g1, gx))\n&gt;\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#428-key-share","title":"4.2.8. Key Share","text":"<p>The key share extension is modelled using macros. Named groups are global values and the key exchange contains the calculated value for the key.</p> RFC 8446<pre><code>Clients MAY send an empty client_shares vector in order to request\ngroup selection from the server, at the cost of an additional round\ntrip (see Section 4.1.4).\n\n    struct {\n        NamedGroup group;\n        opaque key_exchange&lt;1..2^16-1&gt;;\n    } KeyShareEntry;\n\ngroup:  The named group for the key being exchanged.\n\nkey_exchange:  Key exchange information.  The contents of this field\n    are determined by the specified group and its corresponding\n    definition.  Finite Field Diffie-Hellman [DH76] parameters are\n    described in Section 4.2.8.1; Elliptic Curve Diffie-Hellman\n    parameters are described in Section 4.2.8.2.\n\nIn the ClientHello message, the \"extension_data\" field of this\nextension contains a \"KeyShareClientHello\" value:\n\n    struct {\n        KeyShareEntry client_shares&lt;0..2^16-1&gt;;\n    } KeyShareClientHello;\n\nclient_shares:  A list of offered KeyShareEntry values in descending\n    order of client preference.\n</code></pre> src/model/macros.splib<pre><code>KeyShareEntry(named_group, key_exchange) = &lt;named_group, key_exchange&gt;,\nExtensionKeyShare(share) = Extension('51', share),\n</code></pre> src/model/client.splib<pre><code>ExtensionKeyShare(KeyShareEntry($g1, gx))\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#4281-diffie-hellman-parameters","title":"4.2.8.1. Diffie-Hellman Parameters","text":"<p>The diagram below shows how the two parties agree on DHE parameters.</p> RFC 8446<pre><code>Diffie-Hellman [DH76] parameters for both clients and servers are\nencoded in the opaque key_exchange field of a KeyShareEntry in a\nKeyShare structure.  The opaque value contains the Diffie-Hellman\npublic value (Y = g^X mod p) for the specified group (see [RFC7919]\nfor group definitions) encoded as a big-endian integer and padded to\nthe left with zeros to the size of p in bytes.\n\nNote: For a given Diffie-Hellman group, the padding results in all\npublic keys having the same length.\n\nPeers MUST validate each other's public key Y by ensuring that 1 &lt; Y\n&lt; p-1.  This check ensures that the remote peer is properly behaved\nand isn't forcing the local system into a small subgroup.\n</code></pre> src/model/client.splib<pre><code>gx = $g1^~x\nExtensionKeyShare(KeyShareEntry($g1, gx))\n</code></pre> <pre><code>    Client                        Server\nsupports g1, g2               supports g\n\n&lt;g1, g2&gt;, &lt;g1, g1^x&gt; ----&gt;  if g != g1\n\n                    &lt;----- HRR &lt;g&gt;\n\nchecks g2 == g \n&lt;g1, g2&gt;, &lt;g2, g2^x2&gt; ----&gt;  checks g == g2\n\n                    &lt;------ &lt;g, g^y&gt;\n\n\n                Both parties compute\n                        g^xy\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#4282-ecdhe-parameters","title":"4.2.8.2. ECDHE Parameters","text":"<p>For the symbolic model there is no specific modelling of the ECDHE parameters.</p>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#429-pre-shared-key-exchange-modes","title":"4.2.9. Pre-Shared Key Exchange Modes","text":"<p>The client as always supports both modes, allowing the server to choose between <code>psk_ke</code> and <code>psk_dhe_ke</code>.</p> RFC 8446<pre><code>In order to use PSKs, clients MUST also send a\n\"psk_key_exchange_modes\" extension.  The semantics of this extension\nare that the client only supports the use of PSKs with these modes,\nwhich restricts both the use of PSKs offered in this ClientHello and\nthose which the server might supply via NewSessionTicket.\n\nA client MUST provide a \"psk_key_exchange_modes\" extension if it\noffers a \"pre_shared_key\" extension.  If clients offer\n\"pre_shared_key\" without a \"psk_key_exchange_modes\" extension,\nservers MUST abort the handshake.  Servers MUST NOT select a key\nexchange mode that is not listed by the client.  This extension also\nrestricts the modes for use with PSK resumption.  Servers SHOULD NOT\nsend NewSessionTicket with tickets that are not compatible with the\nadvertised modes; however, if a server does so, the impact will just\nbe that the client's attempts at resumption fail.\n\nThe server MUST NOT send a \"psk_key_exchange_modes\" extension.\n\n    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;\n\n    struct {\n        PskKeyExchangeMode ke_modes&lt;1..255&gt;;\n    } PskKeyExchangeModes;\n\npsk_ke:  PSK-only key establishment.  In this mode, the server\n    MUST NOT supply a \"key_share\" value.\n\npsk_dhe_ke:  PSK with (EC)DHE key establishment.  In this mode, the\n    client and server MUST supply \"key_share\" values as described in\n    Section 4.2.8.\n\nAny future values that are allocated must ensure that the transmitted\nprotocol messages unambiguously identify which mode was selected by\nthe server; at present, this is indicated by the presence of the\n\"key_share\" in the ServerHello.\n</code></pre> src/model/macros.splib<pre><code>PskKeyExchangeModePskKe() = '0',\nPskKeyExchangeModePskDheKe() = '1',\nExtensionPskKeyExchangeModes(ke_mode) = Extension('45', ke_mode),\n</code></pre> src/model/clientPsk.splib<pre><code>psk_ke_mode = &lt;PskKeyExchangeModePskKe(), PskKeyExchangeModePskDheKe()&gt;\n\n...\n\nExtensionPskKeyExchangeModes(psk_ke_mode),\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#4210-early-data-indication","title":"4.2.10. Early Data Indication","text":"<p>When sending a <code>ClientHello</code> for a PSK handshake, space is always allocated for the <code>EarlyDataIndication</code> extension. However, depending on whether the extension should be used or not, the value is changed locally.</p> <p>This allows us to pattern match on the server-side the client sending a hello with the extension present or not. For example, the client always sends this extension on the first PSK handshake attempt, but if the server sends a HRR in response to the initial message, the client never sends the extension on the second flight.</p> <p>As noted in the PSK extension section, we use a pair of functions mask, unmask to capture the obfuscated ticket age mechanism, though it is not clear if this models anything interesting.</p> <p>The <code>EndOfEarlyData</code> message message is currently not modelled.</p> RFC 8446<pre><code>When a PSK is used, the client can send application data in its first flight of messages. If the client opts to do so, it MUST supply an \"early_data\" extension as well as the \"pre_shared_key\" extension.\n\nThe \"extension_data\" field of this extension contains an \"EarlyDataIndication\" value:\n\n   struct {} Empty;\n\n   struct {\n       select (Handshake.msg_type) {\n           case new_session_ticket:   uint32 max_early_data_size;\n           case client_hello:         Empty;\n           case encrypted_extensions: Empty;\n       };\n   } EarlyDataIndication;\n\nSee for the use of the max_early_data_size field.\n\nThe parameters for the 0-RTT data (symmetric cipher suite, ALPN protocol, etc.) are the same as those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's \"pre_shared_key\" extension.\n\nFor PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see ). If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.\n\n0-RTT messages sent in the first flight have the same (encrypted) content types as their corresponding messages sent in other flights (handshake and application_data) but are protected under different keys. After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change. This message will be encrypted with the 0-RTT traffic keys.\n</code></pre> src/model/macros.splib<pre><code>ExtensionEarlyDataIndication() = Extension('42', &lt;'0'&gt;),\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_02_extensions/#4211-pres-shared-key-extension","title":"4.2.11. Pres-Shared Key Extension","text":""},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_05_end_of_early_data/","title":"4.5. End of Early Data","text":"<p>The <code>EndOfEarlyData</code> message is currently not modelled.</p>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_06_post_handshake_messages/","title":"4.6. Post-Handshake Messages","text":"RFC 8446<pre><code>TLS also allows other messages to be sent after the main handshake.\nThese messages use a handshake content type and are encrypted under\nthe appropriate application traffic key.\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_06_post_handshake_messages/#461-new-session-ticket-message","title":"4.6.1. New Session Ticket Message","text":"<p>Currently the server can send a <code>NewSessionTicket</code> message using the rule <code>new_session_ticket</code>. The corresponding <code>recv_</code> rule on the client side completes the exchange by receiving the message and generating the relevant values. That is, the lifetime of a session ticket is not modelled at the moment. When the server/client sends/receives resp. the NewSessionTicket message, they also output a !Server/!ClientPSK fact which encapsulates the PSK state:</p> <p><code>!ServerPSK(S, C, res_psk, auth_status, NewSessionTicket, 'nst'),</code></p> <p>This stores: * server and client identities * resumption master secret (res_psk) * authentication status of the peer * NewSessionTicket message blob, containing all other variables (ticket, ticket_age_add, etc.) * type of session ticket ('nst' for NewSessionTicket, 'oob' for out of band PSK)</p> RFC 8446<pre><code>At any time after the server has received the client Finished\nmessage, it MAY send a NewSessionTicket message.  This message\ncreates a unique association between the ticket value and a secret\nPSK derived from the resumption master secret (see Section 7).\n</code></pre> RFC 8446<pre><code>struct {\n    uint32 ticket_lifetime;\n    uint32 ticket_age_add;\n    opaque ticket_nonce&lt;0..255&gt;;\n    opaque ticket&lt;1..2^16-1&gt;;\n    Extension extensions&lt;0..2^16-2&gt;;\n} NewSessionTicket;\n</code></pre> src/model/macros.splib<pre><code>NewSessionTicket(ticket_lifetime, ticket_age_add, ticket, ticket_extension) = Handshake(HandshakeMessageTypeNewSessionTicket(), &lt;ticket_lifetime, ticket_age_add, ticket, ticket_extension&gt;),\n</code></pre> src/model/server.splib<pre><code>ticket_extension = &lt;\n    &lt;'46', $max_early_data_size&gt;\n&gt;\nmessage = NewSessionTicket($ticket_lifetime, ~ticket_age_add, ~ticket, ticket_extension)\n</code></pre>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_06_post_handshake_messages/#462-post-handshake-authentication","title":"4.6.2. Post-Handshake Authentication","text":"RFC 8446<pre><code>When the client has sent the \"post_handshake_auth\" extension (see\nSection 4.2.6), a server MAY request client authentication at any\ntime after the handshake has completed by sending a\nCertificateRequest message.  The client MUST respond with the\nappropriate Authentication messages (see Section 4.4).  If the client\nchooses to authenticate, it MUST send Certificate, CertificateVerify,\n\nand Finished.  If it declines, it MUST send a Certificate message\ncontaining no certificates followed by Finished.  All of the client's\nmessages for a given response MUST appear consecutively on the wire\nwith no intervening messages of other types.\n\nA client that receives a CertificateRequest message without having\nsent the \"post_handshake_auth\" extension MUST send an\n\"unexpected_message\" fatal alert.\n\nNote: Because client authentication could involve prompting the user,\nservers MUST be prepared for some delay, including receiving an\narbitrary number of other messages between sending the\nCertificateRequest and receiving a response.  In addition, clients\nwhich receive multiple CertificateRequests in close succession MAY\nrespond to them in a different order than they were received (the\ncertificate_request_context value allows the server to disambiguate\nthe responses).\n</code></pre> <p>There are two main concerns to model:</p> <ol> <li>Optional client auth</li> <li>Multiple concurrent auth reqs/responses</li> </ol> <p>The first one is currently not supported. That is, the client will either never reply, or will send a certificate. Server certificate requests generate a new <code>ServerCertReq</code> fact which encapsulates the server storing additional state to track the certificate requests. This value is: <code>ServerCertReq(tid, S, C, certificate_request_context),</code> which tracks the current session (tid), the identities of server and client, and the context value used to disambiguate the requests. The client has equivalent facts for the same purpose.</p>"},{"location":"RFC%20Mapping/4.%20Handshake%20Protocol/04_06_post_handshake_messages/#463-key-and-initialization-vector-update","title":"4.6.3. Key and Initialization Vector Update","text":"<p>All key update related rules can be found in <code>src/model/keyUpdate.splib</code>.</p> <pre><code>enum {\n    update_not_requested(0), update_requested(1), (255)\n} KeyUpdateRequest;\n\nstruct {\n    KeyUpdateRequest request_update;\n} KeyUpdate;\n</code></pre> src/model/macros.splib<pre><code>KeyUpdateUpdateNotRequested() = '0',\nKeyUpdateUpdateRequested() = '1',\nKeyUpdate(update_requested) = Handshake(HandshakeMessageTypeKeyUpdate(), &lt;update_requested&gt;),\n</code></pre>"},{"location":"RFC%20Mapping/5.%20Record%20Protocol/","title":"5. Record Protocol","text":"<p>The modelling of the Record Protocol is quite coarse, and simply treats all encryption as chunks of authenticated encryption. The abstract modelled Record Protocol is described in section 5.1.</p>"},{"location":"RFC%20Mapping/5.%20Record%20Protocol/05_01_record_layer/","title":"5.1. Record Layer","text":"RFC 8446<pre><code>enum {\n    invalid(0),\n    change_cipher_spec(20),\n    alert(21),\n    handshake(22),\n    application_data(23),\n    (255)\n} ContentType;\n\nstruct {\n    ContentType type;\n    ProtocolVersion legacy_record_version;\n    uint16 length;\n    opaque fragment[TLSPlaintext.length];\n} TLSPlaintext;\n</code></pre> src/model/macros.splib<pre><code>DataRecord(data) = &lt;data, '23'&gt;\n</code></pre> <p>Sending and receiving data is modelled by sending and receiving some fresh term <code>~data</code>. The keys used for encryption are stored in the <code>SendStream</code> and <code>RecvStream</code> facts which are introduced here.</p> src/model/record.splib<pre><code>rule send:\n    [\n        SendStream(~tid, $actor, $peer, auth_status, app_key_out),\n        Fr(~data)\n    ]\n    --[\n        Send(~tid),\n        SendData(~tid, $actor, $peer, auth_status, ~data)\n    ]-&gt;\n    [\n        SendStream(~tid, $actor, $peer, auth_status, app_key_out),\n        MessageOut(senc{DataRecord(~data)}app_key_out)\n    ]\n</code></pre> src/model/record.splib<pre><code>rule recv:\n    [\n        RecvStream(~tid, $actor, $peer, auth_status, app_key_in),\n        F_MessageIn(senc{DataRecord(data)}app_key_in)\n    ]\n    --[\n        Recv(~tid),\n        RecvData(~tid, $actor, $peer, auth_status, data)\n    ]-&gt;\n    [\n      RecvStream(~tid, $actor, $peer, auth_status, app_key_in)\n    ]\n</code></pre>"},{"location":"RFC%20Mapping/5.%20Record%20Protocol/05_02_record_payload_protection/","title":"5.2. Record Payload Protection","text":"RFC 8446<pre><code>The record protection functions translate a TLSPlaintext structure\ninto a TLSCiphertext structure.  The deprotection functions reverse\nthe process.  In TLS 1.3, as opposed to previous versions of TLS, all\nciphers are modeled as \"Authenticated Encryption with Associated\nData\" (AEAD) [RFC5116].  AEAD functions provide a unified encryption\nand authentication operation which turns plaintext into authenticated\nciphertext and back again.  Each encrypted record consists of a\nplaintext header followed by an encrypted body, which itself contains\na type and optional padding.\n</code></pre> <p>The record payload protection is not modelled in detail. For more information have a look at section 5.</p>"},{"location":"RFC%20Mapping/5.%20Record%20Protocol/05_03_per_record_nonce/","title":"5.3. Per-Record Nonce","text":"RFC 8446<pre><code>A 64-bit sequence number is maintained separately for reading and\nwriting records.  The appropriate sequence number is incremented by\none after reading or writing each record.  Each sequence number is\nset to zero at the beginning of a connection and whenever the key is\nchanged; the first record transmitted under a particular traffic key\nMUST use sequence number 0.\n</code></pre> <p>As explained in section 5 the modelling of the Record Protocol is quite coarse. The Per-Record Nonce is not modelled at the moment.</p>"},{"location":"RFC%20Mapping/5.%20Record%20Protocol/05_04_record_padding/","title":"5.4. Record Padding","text":"RFC 8446<pre><code>All encrypted TLS records can be padded to inflate the size of the\nTLSCiphertext.  This allows the sender to hide the size of the\ntraffic from an observer.\n</code></pre> <p>The record modelled has no specific length property or something similar. For more information have a look at section 5.</p>"},{"location":"RFC%20Mapping/5.%20Record%20Protocol/05_05_limits_on_key_usage/","title":"5.5. Limits on Key Usage","text":"RFC 8446<pre><code>There are cryptographic limits on the amount of plaintext which can\nbe safely encrypted under a given set of keys.  [AEAD-LIMITS]\nprovides an analysis of these limits under the assumption that the\nunderlying primitive (AES or ChaCha20) has no weaknesses.\nImplementations SHOULD do a key update as described in Section 4.6.3\nprior to reaching these limits.\n\nFor AES-GCM, up to 2^24.5 full-size records (about 24 million) may be\nencrypted on a given connection while keeping a safety margin of\napproximately 2^-57 for Authenticated Encryption (AE) security.  For\nChaCha20/Poly1305, the record sequence number would wrap before the\nsafety limit is reached.\n</code></pre> <p>The RFC states that at specific timepoint implementations should initiate a key update as described in section 4.6.3.</p>"},{"location":"RFC%20Mapping/6.%20Alert%20Protocol/","title":"6. Alert Protocol","text":"<p>The alert protocol is not modelled at the moment.</p>"},{"location":"RFC%20Mapping/7.%20Cryptographic%20Computations/07_01_key_schedule/","title":"7.1. Key Schedule","text":"<pre><code>The key derivation process makes use of the HKDF-Extract and\nHKDF-Expand functions as defined for HKDF [RFC5869], as well as the\nfunctions defined below:\n\n    HKDF-Expand-Label(Secret, Label, Context, Length) =\n        HKDF-Expand(Secret, HkdfLabel, Length)\n\n    Where HkdfLabel is specified as:\n\n    struct {\n        uint16 length = Length;\n        opaque label&lt;7..255&gt; = \"tls13 \" + Label;\n        opaque context&lt;0..255&gt; = Context;\n    } HkdfLabel;\n\n    Derive-Secret(Secret, Label, Messages) =\n        HKDF-Expand-Label(Secret, Label,\n                            Transcript-Hash(Messages), Hash.length)\n</code></pre> <p>To map the Derive-Secret function described above and all dependencies, two functions are defined in Tamarin: Expand and Extract.</p> <pre><code>functions: Expand/3, Extract/2\n</code></pre> <pre><code>            0\n            |\n            v\nPSK -&gt;  HKDF-Extract = Early Secret\n            |\n            +-----&gt; Derive-Secret(., \"ext binder\" | \"res binder\", \"\")\n            |                     = binder_key\n            |\n            +-----&gt; Derive-Secret(., \"c e traffic\", ClientHello)\n            |                     = client_early_traffic_secret\n            |\n            +-----&gt; Derive-Secret(., \"e exp master\", ClientHello)\n            |                     = early_exporter_master_secret\n            v\n    Derive-Secret(., \"derived\", \"\")\n            |\n            v\n</code></pre> <pre><code># rule client_hello\nearlySecret = Extract('0', '0')\n\n# rule client_hello_psk\nes = Extract(res_psk, '0')\n</code></pre> <pre><code>(EC)DHE -&gt; HKDF-Extract = Handshake Secret\n            |\n            +-----&gt; Derive-Secret(., \"c hs traffic\",\n            |                     ClientHello...ServerHello)\n            |                     = client_handshake_traffic_secret\n            |\n            +-----&gt; Derive-Secret(., \"s hs traffic\",\n            |                     ClientHello...ServerHello)\n            |                     = server_handshake_traffic_secret\n            v\n    Derive-Secret(., \"derived\", \"\")\n            |\n            v\n</code></pre> <pre><code># rule client_gen_keys\nhandshakeSecret = Extract(p_gxy, p_es)\n</code></pre> <pre><code>0 -&gt; HKDF-Extract = Master Secret\n            |\n            +-----&gt; Derive-Secret(., \"c ap traffic\",\n            |                     ClientHello...server Finished)\n            |                     = client_application_traffic_secret_0\n            |\n            +-----&gt; Derive-Secret(., \"s ap traffic\",\n            |                     ClientHello...server Finished)\n            |                     = server_application_traffic_secret_0\n            |\n            +-----&gt; Derive-Secret(., \"exp master\",\n            |                     ClientHello...server Finished)\n            |                     = exporter_master_secret\n            |\n            +-----&gt; Derive-Secret(., \"res master\",\n                                ClientHello...client Finished)\n                                = resumption_master_secret\n</code></pre>"},{"location":"RFC%20Mapping/7.%20Cryptographic%20Computations/07_02_updating_traffic_secrets/","title":"7.2. Updating Traffic Secrets","text":"RFC 8446<pre><code>Once the handshake is complete, it is possible for either side to\nupdate its sending traffic keys using the KeyUpdate handshake message\ndefined in Section 4.6.3.  The next generation of traffic keys is\ncomputed by generating client_/server_application_traffic_secret_N+1\nfrom client_/server_application_traffic_secret_N as described in this\nsection and then re-deriving the traffic keys as described in\nSection 7.3.\n\nThe next-generation application_traffic_secret is computed as:\n\n    application_traffic_secret_N+1 =\n        HKDF-Expand-Label(application_traffic_secret_N,\n                            \"traffic upd\", \"\", Hash.length)\n\nOnce client_/server_application_traffic_secret_N+1 and its associated\ntraffic keys have been computed, implementations SHOULD delete\nclient_/server_application_traffic_secret_N and its associated\ntraffic keys.\n</code></pre> <p>keyUpdate.splib<pre><code>sats = Expand(p_sats, &lt;'ats', '0'&gt;, '32')\ncats = Expand(p_cats, &lt;'ats', '0'&gt;, '32')\n</code></pre> The traffic key update for the key update mentioned here or in section 4.6.3. <code>p_sats</code> and <code>p_cats</code> are the corresponding <code>application_traffic_secret_N</code> and <code>cats</code> and <code>sats</code> are the corresponding <code>application_traffic_secret_N+1</code>.</p>"},{"location":"RFC%20Mapping/7.%20Cryptographic%20Computations/07_03_traffic_key_calculation/","title":"7.3. Traffic Key Calculation","text":""},{"location":"RFC%20Mapping/7.%20Cryptographic%20Computations/07_04_ecdhe_shared_secret_calculation/","title":"7.4. (EC)DHE Shared Secret Calculation","text":""},{"location":"RFC%20Mapping/8.%200-RTT%20and%20Anti-Replay/","title":"8.","text":""},{"location":"RFC%20Mapping/9.%20Compliance%20Requirements/","title":"9. Compliance Requirements","text":"<p>Compliance requirements are currently not relevant for this symbolic model.</p>"},{"location":"RFC%20Mapping/A.%20State%20Machine/","title":"A. State Machine","text":"RFC 8446<pre><code>This appendix provides a summary of the legal state transitions for\nthe client and server handshakes.  State names (in all capitals,\ne.g., START) have no formal meaning but are provided for ease of\ncomprehension.  Actions which are taken only in certain circumstances\nare indicated in [].  The notation \"K_{send,recv} = foo\" means \"set\nthe send/recv key to the given key\".\n</code></pre> <p>The state machines shown in the following section won't map completely to the RFC. This is because of the model not covering all TLS features and extensions.</p>"},{"location":"RFC%20Mapping/A.%20State%20Machine/a_01_client/","title":"A.1. Client","text":"RFC 8446<pre><code>                          START &lt;----+\n           Send ClientHello |        | Recv HelloRetryRequest\n      [K_send = early data] |        |\n                            v        |\n       /                 WAIT_SH ----+\n       |                    | Recv ServerHello\n       |                    | K_recv = handshake\n   Can |                    V\n  send |                 WAIT_EE\n early |                    | Recv EncryptedExtensions\n  data |           +--------+--------+\n       |     Using |                 | Using certificate\n       |       PSK |                 v\n       |           |            WAIT_CERT_CR\n       |           |        Recv |       | Recv CertificateRequest\n       |           | Certificate |       v\n       |           |             |    WAIT_CERT\n       |           |             |       | Recv Certificate\n       |           |             v       v\n       |           |              WAIT_CV\n       |           |                 | Recv CertificateVerify\n       |           +&gt; WAIT_FINISHED &lt;+\n       |                  | Recv Finished\n       \\                  | [Send EndOfEarlyData]\n                          | K_send = handshake\n                          | [Send Certificate [+ CertificateVerify]]\nCan send                  | Send Finished\napp data   --&gt;            | K_send = K_recv = application\nafter here                v\n                      CONNECTED\n</code></pre> <pre><code>stateDiagram-v2\n    [*] --&gt; C0\n\n    C0 --&gt; C1 : client_hello\n    C1 --&gt; C1 : recv_hello_retry_request\n    C1 --&gt; C2a : recv_server_hello\n\n    C2a --&gt; C2b : client_gen_keys\n    C2b --&gt; C2c : recv_encrypted_extensions\n\n    C2c --&gt; C2d : recv_certificate_request\n    C2c --&gt; C2d : skip_recv_certificate_request\n\n    C2d --&gt; C3 : recv_server_auth\n\n    C3 --&gt; C4 : client_auth&lt;br&gt;(cert_req_ctxt \u2260 0)\n    C3 --&gt; C4 : client_auth_cert&lt;br&gt;(cert_req_ctxt = 0)\n\n    C4 --&gt; C4 : recv_new_session_ticket</code></pre>"},{"location":"RFC%20Mapping/A.%20State%20Machine/a_02_server/","title":"A.2. Server","text":"<pre><code>                             START &lt;-----+\n              Recv ClientHello |         | Send HelloRetryRequest\n                               v         |\n                            RECVD_CH ----+\n                               | Select parameters\n                               v\n                            NEGOTIATED\n                               | Send ServerHello\n                               | K_send = handshake\n                               | Send EncryptedExtensions\n                               | [Send CertificateRequest]\nCan send                       | [Send Certificate + CertificateVerify]\napp data                       | Send Finished\nafter   --&gt;                    | K_send = application\nhere                  +--------+--------+\n             No 0-RTT |                 | 0-RTT\n                      |                 |\n  K_recv = handshake  |                 | K_recv = early data\n[Skip decrypt errors] |    +------&gt; WAIT_EOED -+\n                      |    |       Recv |      | Recv EndOfEarlyData\n                      |    | early data |      | K_recv = handshake\n                      |    +------------+      |\n                      |                        |\n                      +&gt; WAIT_FLIGHT2 &lt;--------+\n                               |\n                      +--------+--------+\n              No auth |                 | Client auth\n                      |                 |\n                      |                 v\n                      |             WAIT_CERT\n                      |        Recv |       | Recv Certificate\n                      |       empty |       v\n                      | Certificate |    WAIT_CV\n                      |             |       | Recv\n                      |             v       | CertificateVerify\n                      +-&gt; WAIT_FINISHED &lt;---+\n                               | Recv Finished\n                               | K_recv = application\n                               v\n                           CONNECTED\n</code></pre> <pre><code>stateDiagram-v2\n    [*] --&gt; S0\n\n    S0 --&gt; S1 : recv_client_hello\n    S1 --&gt; S0 : hello_retry_request\n    S1 --&gt; S2a : server_hello\n\n    S2a --&gt; S2b : server_gen_keys\n    S2b --&gt; S2c : encrypted_extensions\n\n    S2c --&gt; S2d : certificate_request\n    S2c --&gt; S2d : skip_certificate_request\n\n    S2d --&gt; S3 : server_auth\n\n    S3 --&gt; S4 : recv_client_auth\\n(cert_req_ctxt \u2260 0)\n    S3 --&gt; S4 : recv_client_auth_cert\\n(cert_req_ctxt = 0)\n\n    S4 --&gt; S4 : new_session_ticket</code></pre>"},{"location":"RFC%20Mapping/B.%20Protocol%20Data%20Structures%20and%20Constant%20Values/","title":"B. Protocol Data Structures and Constant Values","text":"<p>Protocol data structures or constant values are mentioned in the sections where they are used. Therefor this section is empty for now.</p>"},{"location":"RFC%20Mapping/C.%20Implementation%20Notes/","title":"C. Implementation Notes","text":"<p>As this model is not an implementation of TLS the implementation notes don't effect the model. Therefor this section is empty for now.</p>"},{"location":"RFC%20Mapping/D.%20Backward%20Compatibility/","title":"D. Backward Compatibility","text":"<p>Backward Compatibility is not modelled at the moment.</p>"},{"location":"RFC%20Mapping/E.%20Overview%20of%20Security%20Properties/","title":"E. Overview of Security Properties","text":"<p>This section is still work in progress.</p>"},{"location":"history/","title":"History","text":"<p>The history of the model consists of three specific versions. The first version of the model was related to Draft 10 of the TLS specification and published in 2016. In the next year an updated version for Draft 21 was released. In 2025 the model was optimized and aligned to RFC 8446.</p> <ul> <li>2025 (RFC 8446) - TLS 1.3 Tamarin model</li> <li>2017 (Draft 21) - A Comprehensive Symbolic Analysis of TLS 1.3</li> <li>2016 (Draft 10) - Automated Analysis of TLS 1.3: 0-RTT, Resumption and Delayed Authentication</li> </ul>"},{"location":"lemmas/","title":"Lemmas","text":"<p>All lemmas are located in the <code>src/lemmas</code> subfolder. They are splitted into several groups which then are</p> <pre><code>graph LR\n    A[reachability] --&gt; B[uniqueness]\n    B --&gt; C[invariants]\n    B --&gt; D[dhCal]\n    B --&gt; E[dhInj]\n    C --&gt; F[authHelpers]\n    C --&gt; F[secretHelpers]\n    D --&gt; F</code></pre> <pre><code>\ud83d\udce6TLS13Tamarin\n \u2517 \ud83d\udcc2src\n   \u2517 \ud83d\udcc2lemmas\n     \u2523 \ud83d\udcdcatMostOf.splib # (1)\n     \u2523 \ud83d\udcdcauthHelpers.splib # (2)\n     \u2523 \ud83d\udcdcdhCal.splib # (3)\n     \u2523 \ud83d\udcdcdhInj.splib # (4)\n     \u2523 \ud83d\udcdcinvariants.splib # (5)\n     \u2523 \ud83d\udcdclemmas.splib # (6)\n     \u2523 \ud83d\udcdconePerTid.splib # (7)\n     \u2523 \ud83d\udcdcreachability.splib # (8)\n     \u2523 \ud83d\udcdcrestrictions.splib # (9)\n     \u2523 \ud83d\udcdcsecretHelpers.splib # (10)\n     \u2517 \ud83d\udcdcuniqueness.splib # (11)\n</code></pre> <ol> <li>abc</li> <li>ab</li> <li>ab</li> <li></li> <li>ab</li> <li>ab</li> <li></li> <li>Sanity checks to proof that all states are reachable.</li> <li>Global restrictions for the model and also source lemmas.</li> <li></li> <li>Checks that states are unique in a given session.</li> </ol> <p>Lemmas are related to TLS security properties as follows:</p> Security Property Lemma 0 1 2 3 4 5"},{"location":"lemmas/reachability/","title":"Reachability","text":""},{"location":"lemmas/uniqueness/","title":"Uniqueness","text":""},{"location":"model/","title":"Model","text":"<p>The Multiset-Rewriting-Rules are split into several security protocol library files (<code>.splib</code>).</p> <pre><code>\ud83d\udce6TLS13Tamarin\n \u2517 \ud83d\udcc2src\n   \u2517 \ud83d\udcc2model\n     \u2523 \ud83d\udcdcclient.splib # (1)\n     \u2523 \ud83d\udcdcclientPsk.splib # (2)\n     \u2523 \ud83d\udcdcearlyData.splib # (3)\n     \u2523 \ud83d\udcdckeyUpdate.splib # (4)\n     \u2523 \ud83d\udcdcmacros.splib # (5)\n     \u2523 \ud83d\udcdcpostHandshake.splib # (6)\n     \u2523 \ud83d\udcdcpublicKeyInfrastructure.splib # (7)\n     \u2523 \ud83d\udcdcrecord.splib # (8)\n     \u2523 \ud83d\udcdcreveal.splib # (9)\n     \u2523 \ud83d\udcdcserver.splib # (10)\n     \u2517 \ud83d\udcdcserverPsk.splib # (11)\n</code></pre> <ol> <li>abc</li> <li>ab</li> <li>ab</li> <li>Rules related to the default key update defined in RFC 8446 Section 4.6.3. More</li> <li>ab</li> <li>ab</li> <li>Contains the rules dictating the public-key infrastructure. More</li> <li>ab</li> <li>ab</li> <li>abc</li> <li>abc</li> </ol>"},{"location":"model/batch_tamarin_recipe/","title":"Batch-Tamarin recipe","text":"<p>This model makes use of a python wrapper for Tamarin models called Batch-Tamarin. It helps to (re)proof all lemmas in a resource efficient manner. After installing Batch-Tamarin one can navigate to <code>src</code> and then simply run <code>batch-tamarin run recipe.json</code> to reproof all automatic lemmas.</p>"},{"location":"model/client_and_server_state_facts/","title":"Client and Server state facts","text":"Index Name Description 0 1 2 3 4 5"},{"location":"model/hello_retry_request/","title":"Hello Retry Request","text":"<p>The Hello Retry Request is actually a special <code>ServerHello</code> message. It uses the a constant value for the Random value of the <code>ServerHello</code> struct.</p> <pre><code>For reasons of backward compatibility with middleboxes (see\nAppendix D.4), the HelloRetryRequest message uses the same structure\nas the ServerHello, but with Random set to the special value of the\nSHA-256 of \"HelloRetryRequest\":\n\n  CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91\n  C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C\n\nUpon receiving a message with type server_hello, implementations MUST\nfirst examine the Random value and, if it matches this value, process\nit as described in Section 4.1.4).\n</code></pre> <p>In Tamarin the special value is modelled using a macro <code>HelloRetryRequestRandom() = h('HelloRetryRequest')</code> in the <code>macros.splib</code>.</p>"},{"location":"model/key_update/","title":"Key Update","text":""},{"location":"model/out_of_band_psk/","title":"Out of band PSK","text":"<p>For the establishment of a out of band PSK the rule <code>out_of_band_psk</code> is used. It only uses fresh facts as a premise so it can be instantiated at any time. To indicate out of band usage the authentication status for both peers is set to a constant string of <code>oob_auth</code>.</p> src/model/publicKeyInfrastructure.splib<pre><code>rule out_of_band_psk:\n    let\n        auth_status = &lt;'oob_auth', 'oob_auth'&gt;\n        sessionTicket = &lt;'4', $ticket_lifetime, ~ticket_age_add, ~ticket, &lt;&lt;'46', $max_early_data_size&gt;&gt;&gt;\n    in\n    [\n        Fr(~ticket),\n        Fr(~res_psk),\n        Fr(~ticket_age_add)\n    ]\n    --[\n        GenPSK($S, 'server'),\n        GenPSK($C, 'client'),\n        FreshPSK(~ticket, ~res_psk)\n    ]-&gt;\n    [\n        !ClientPSK($C, $S, ~res_psk, auth_status, sessionTicket, 'ext'),\n        !ServerPSK($S, $C, ~res_psk, auth_status, sessionTicket, 'ext'),\n        F_SecretPSK($S, ~res_psk),\n        F_SecretPSK($C, ~res_psk)\n    ]\n</code></pre>"},{"location":"model/public_key_infrastructure/","title":"PKI","text":"<p>The PKI is based on the</p>"},{"location":"model/public_key_infrastructure/#registering-public-keys","title":"Registering public keys","text":"<p>The rule registering public keys is <code>Register_pk</code>.</p>"},{"location":"model/public_key_infrastructure/#out-of-band-psk","title":"Out of band PSK","text":""}]}