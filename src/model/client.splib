rule client_hello:
    let
        messages = '0'
        supported_groups = <$g1, $g2>
        gx = $g1^~x
        extensions = <
            ExtensionSupportedVersions(),
            ExtensionNamedGroupdList(supported_groups),
            ExtensionSignatureSchemeList($sig_algs),
            ExtensionKeyShare(KeyShareEntry($g1, gx))
        >
        message = ClientHello(~nc, '0', $cipher_suites, '0', extensions)
        messages = <messages, message>
        earlySecret = Extract('0', '0')
    in
    [
        Fr(~nc),
        Fr(~x)
    ]
    --[
        C0(~nc),
        Start(~nc, $C, 'client'),
        RIdentity(~nc, $C, 'client', <$C>),
        Neq($g1, $g2),
        DH(~nc, $C, ~x),
        HonestUse(~x),
        HonestUse(gx)
    ]->
    [
        ClientState(
            ~nc,
            'C1',
            $C,
            $S,
            '0',
            messages,
            ~nc,
            '0',
            $g1,
            supported_groups,
            '0',
            ~x,
            '0',
            gx,
            '0',
            '0',
            'na',
            '0',
            '0',
            earlySecret,
            '0',
            '0',
            '0',
            '0',
            '0',
            '0',
            <'0', '0'>,
            '0',
            '0',
            '0'
        ),
        DHExp(~x, ~nc, $C),
        !DHEx(~x, ~nc, $C),
        MessageOut(message)
    ]

rule recv_hello_retry_request:
    let
        p_g = $g1
        p_hrr = '0'
        hrr = 'hrr'
        supported_groups = <$g1, $g2>
        psk_ke_mode = 'na'
        auth_status = <'0', '0'>
        gx = $g2^~new_x
        receivedExtensions = <
            ExtensionSupportedVersions(),
            ExtensionKeyShare($g2)
        >
        receivedMessage = ServerHello(HelloRetryRequestRandom(), '0', $cipher_suites, '0', receivedExtensions)
        messages = <p_messages, receivedMessage>
        extensions = <
            ExtensionSupportedVersions(),
            ExtensionNamedGroupdList(supported_groups),
            ExtensionSignatureSchemeList($supported_signature_algorithms),
            ExtensionKeyShare(KeyShareEntry($g2, gx))
        >
        message = ClientHello(p_nc, '0', $cipher_suites, '0', extensions)
        messages = <messages, message>
        es = Extract(p_res_psk, '0')
    in
    [
        ClientState(
            ~tid,
            'C1',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        Fr(~new_x),
        F_MessageIn(receivedMessage),
        DHExp(p_x, ~tid, $C)
    ]
    --[
        C1_retry(~tid),
        Neq($g1, $g2),
        Instance(~tid, $C, 'client'),
        DeleteDH(~tid, $C, p_x),
        DH(~tid, $C, ~new_x)
    ]->
    [
        MessageOut(message),
        DHExp(~new_x, ~tid, $C),
        !DHEx(~new_x, ~tid, $C),
        ClientState(
            ~tid,
            'C1',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            p_ns,
            $g2,
            p_sg,
            hrr,
            ~new_x,
            p_y,
            gx,
            p_gy,
            p_gxy,
            psk_ke_mode,
            p_psk_id,
            p_edi,
            es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]

rule recv_server_hello:
    let
        p_x = ~x // TODO: Check if really needed.
        serverRandom = new_ns // TODO: check if really needed.
        gy = new_gy
        gy = $g^new_y
        gxy = gy^p_x
        extensions = <
            ExtensionSignatureSchemeList($sig_algs),
            ExtensionKeyShare(KeyShareEntry($g, gy))
        >
        receivedMessage = ServerHello(serverRandom, '0', $cipher_suite, '0', extensions)
        psk_ke_mode = 'na'
        auth_status = <'0', '0'>
        messages = <p_messages, receivedMessage>
    in
    [
        ClientState(
            ~tid,
            'C1',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            $g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        F_MessageIn(receivedMessage)
    ]
    --[
        C1(~tid),
        Instance(~tid, $C, 'client'),
        Neq(gy, $g),
        Neq(gxy, $g),
        Neq(serverRandom, HelloRetryRequestRandom()),
        DHChal($g, p_x, new_y, p_gx, gy, gxy),
        RNonces(~tid, $C, 'client', <p_nc, serverRandom>)
    ]->
    [
        ClientState(
            ~tid,
            'C2a',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            serverRandom,
            $g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            gy,
            gxy,
            psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]

rule client_gen_keys:
    let
        handshakeSecret = Extract(p_gxy, p_es)
        masterSecret = Extract('0', handshakeSecret)
        handshakeKeyClient = Expand(Expand(handshakeSecret, <'TLS13clienthandshaketrafficsecret', <h(p_messages)>>, '32'), <'TLS13handshakekeyexpansion_key', '0'>, '32')
        handshakeKeyServer = Expand(Expand(handshakeSecret, <'TLS13serverhandshaketrafficsecret', <h(p_messages)>>, '32'), <'TLS13handshakekeyexpansion_key', '0'>, '32')
    in
    [
        ClientState(
            ~tid,
            'C2a',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        DHExp(p_x, ~tid, $C)
    ]
    --[
        C2a(~tid),
        Instance(~tid, $C, 'client'),
        RMS(~tid, $C, 'client', <masterSecret>),
        RHS(~tid, $C, 'client', <handshakeSecret>),
        DeleteDH(~tid, $C, p_x)
    ]->
    [
        ClientState(
            ~tid,
            'C2b',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            handshakeSecret,
            masterSecret,
            p_cats,
            p_sats,
            handshakeKeyClient,
            handshakeKeyServer,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]

rule recv_encrypted_extensions:
    let
        receivedMessage = EncryptedExtensions($exts)
        messages = <p_messages, receivedMessage>
    in
    [
        ClientState(
            ~tid,
            'C2b',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        F_MessageIn(senc{receivedMessage}p_hs_keys)
    ]
    --[
        C2b(~tid),
        Instance(~tid, $C, 'client')
    ]->
    [
        ClientState(
            ~tid,
            'C2c',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]

rule skip_recv_certificate_request:
    let
        cert_req = '0'
    in
    [
        ClientState(
            ~tid,
            'C2c',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]
    --[
        C2c(~tid),
        Instance(~tid, $C, 'client')
    ]->
    [
        ClientState(
            ~tid,
            'C2d',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            cert_req
        )
    ]

rule recv_certificate_request:
    let
        p_psk_ke_mode = 'na'
        certificate_request_context = '0'
        cert_req = '1'
        receivedMessage = CertificateRequest(certificate_request_context, $certificate_extensions)
        messages = <p_messages, receivedMessage>
    in
    [
        ClientState(
            ~tid,
            'C2c',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        F_MessageIn(senc{receivedMessage}p_hs_keys)
    ]
    --[
        C2c_req(~tid),
        Instance(~tid, $C, 'client')
    ]->
    [
        ClientState(
            ~tid,
            'C2d',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            cert_req
        )
    ]

rule recv_server_auth:
    let

        // Certificate

        p_psk_ke_mode = 'na'

        certificateMessage = Certificate('0', pk(~ltkS))
        messages = <p_messages, certificateMessage>
        
        sig_messages = <'TLS13server_CertificateVerify', <h(messages)>>

        receivedCertificateVerifyMessage = CertificateVerify(signature)
        messages = <messages, receivedCertificateVerifyMessage>

        exp_verify_data = hmac(Expand(Expand(p_hs, <'TLS13serverhandshaketrafficsecret', <h(messages)>>, '32'), <'TLS13finished', '0'>, '32'), h(messages))

        finishedMessage = Finished(verify_data)
        messages = <messages, finishedMessage>

        earlyMasterSecret = Expand(p_ms, <'TLS13exportermastersecret', <h(messages)>>, '32')
        clientApplicationTrafficSecret = Expand(p_ms, <'TLS13clientapplicationtrafficsecret', <h(messages)>>, '32')
        serverApplicationTrafficSecret = Expand(p_ms, <'TLS13serverapplicationtrafficsecret', <h(messages)>>, '32')
        serverApplicationTrafficKey = Expand(serverApplicationTrafficSecret, <'TLS13applicationdatakeyexpansion_key', '0'>, '32')
        auth_status = <'0', 'auth'>
    in
    [      
        ClientState(
            ~tid,
            'C2d',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        !Pk($S, pk(~ltkS)),
        F_MessageIn(senc{<certificateMessage,receivedCertificateVerifyMessage,finishedMessage>}p_hs_keys)
    ]
    --[
        C2d(~tid),
        Instance(~tid, $C, 'client'),
        Eq(p_psk_ke_mode, 'na'),
        Eq(verify(signature, sig_messages, pk(~ltkS)), true),
        Eq(verify_data, exp_verify_data),
        RMode(~tid, $C, 'client', <p_psk_ke_mode>),
        CIdentity(~tid, $C, 'client', <<$S, auth_status>>),
        CHS(~tid, $C, 'client', <p_hs>),
        CTranscript(~tid, $C, 'client', <messages>),
        CNonces(~tid, $C, 'client', <p_nc, p_ns>)
    ]->
    [
        ClientState(
            ~tid,
            'C3',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            clientApplicationTrafficSecret,
            serverApplicationTrafficSecret,
            p_hs_keyc,
            p_hs_keys,
            auth_status,
            earlyMasterSecret,
            p_rms,
            p_cert_req
        ),
        RecvStream(~tid, $C, $S, auth_status, serverApplicationTrafficKey)
    ]

rule client_auth:
    let
        p_cert_req = '0'
        verify_data = hmac(Expand(Expand(p_hs, <'TLS13clienthandshaketrafficsecret', <h(p_messages)>>, '32'), <'TLS13finished', '0'>, '32'), h(p_messages))
        finishedMessage = Finished(verify_data)
        messages = <p_messages, finishedMessage>

        resumptionMasterSecret = Expand(p_ms, <'TLS13resumptionmastersecret', <h(messages)>>, '32')
        clientApplicationTrafficKey = Expand(p_cats, <'TLS13applicationdatakeyexpansion_key', '0'>, '32')
        serverApplicationTrafficKey = Expand(p_sats, <'TLS13applicationdatakeyexpansion_key', '0'>, '32')
    in
    [
        ClientState(
            ~tid,
            'C3',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]
    --[
        C3(~tid),
        Instance(~tid, $C, 'client'),
        RTranscript(~tid, $C, 'client', <messages>),
        RHSMS(~tid, $C, 'client', <p_hs, p_ms>),
        RRMS(~tid, $C, 'client', <$S, resumptionMasterSecret, messages>),
        RMode(~tid, $C, 'client', <p_psk_ke_mode>),
        SessionKey(~tid, $C, $S, p_auth_status, <clientApplicationTrafficKey, serverApplicationTrafficKey>)
    ]->
    [
        ClientState(
            ~tid,
            'C4',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            resumptionMasterSecret,
            p_cert_req
        ),
        MessageOut(senc{finishedMessage}p_hs_keyc),
        SendStream(~tid, $C, $S, p_auth_status, clientApplicationTrafficKey)
    ]

rule client_auth_cert:
    let
        p_cert_req = '1'
        p_psk_ke_mode = 'na'

        // Certificate
        certificateMessage = Certificate('0', pk(~ltkC))
        messages = <p_messages, certificateMessage>

        // CertificateVerify
        signature = sign{<'TLS13client_CertificateVerify', <h(messages)>>}~ltkC
        certificateVerifyMessage = CertificateVerify(signature)
        messages = <messages, certificateVerifyMessage>

        // Finished
        verify_data = hmac(Expand(Expand(p_hs, <'TLS13clienthandshaketrafficsecret', <h(messages)>>, '32'), <'TLS13finished', '0'>, '32'), h(messages))
        finishedMessage = Finished(verify_data)
        messages = <messages, finishedMessage>

        rms = Expand(p_ms, <'TLS13resumptionmastersecret', <h(messages)>>, '32')

        serverApplicationTrafficKey = Expand(p_sats, <'TLS13applicationdatakeyexpansion_key', '0'>, '32')
        clientApplicationTrafficKey = Expand(p_cats, <'TLS13applicationdatakeyexpansion_key', '0'>, '32')

        auth_status = <'auth', 'auth'>
        cert_req = '0'
    in
    [
        ClientState(
            ~tid,
            'C3',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        RecvStream(~tid, $C, $S, p_auth_status, serverApplicationTrafficKey),
        !Ltk($C, ~ltkC)
    ]
    --[
        C3_cert(~tid),
        Instance(~tid, $C, 'client'),
        UseLtk(~ltkC, signature),
        RHSMS(~tid, $C, 'client', <p_hs, p_ms>),
        RTranscript(~tid, $C, 'client', <messages>),
        RRMS(~tid, $C, 'client', <$S, rms, messages>),
        RMode(~tid, $C, 'client', <p_psk_ke_mode>),
        SessionKey(~tid, $C, $S, auth_status, <clientApplicationTrafficKey, serverApplicationTrafficKey>)
    ]->
    [
        ClientState(
            ~tid,
            'C4',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            auth_status,
            p_ems,
            rms,
            cert_req
        ),
        MessageOut(senc{<certificateMessage,certificateVerifyMessage,finishedMessage>}p_hs_keyc),
        SendStream(~tid, $C, $S, auth_status, clientApplicationTrafficKey),
        RecvStream(~tid, $C, $S, auth_status, serverApplicationTrafficKey)
    ]

rule recv_new_session_ticket:
    let
        p_rms = Expand(ms, <'TLS13resumptionmastersecret', <h(messages)>>, '32')
        ticket_extension = <
            <'46', $max_early_data_size>
        >
        receivedMessage = NewSessionTicket($ticket_lifetime, ticket_age_add, ticket, ticket_extension)
    in
    [
        ClientState(
            ~tid,
            'C4',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        RecvStream(~tid, $C, $S, p_auth_status, serverApplicationTrafficKey),
        F_MessageIn(senc{receivedMessage}serverApplicationTrafficKey)
    ]
    --[
        C4_NST(~tid),
        Instance(~tid, $C, 'client'),
        RPostHS(~tid, $C, 'client', <p_hs, p_rms, $S, p_auth_status, p_messages>)
    ]->
    [
        ClientState(
            ~tid,
            'C4',
            $C,
            $S,
            p_rms,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        RecvStream(~tid, $C, $S, p_auth_status, serverApplicationTrafficKey),
        !ClientPSK($C, $S, p_rms, p_auth_status, receivedMessage, 'res'),
        F_SecretPSK($C, p_rms)
    ]