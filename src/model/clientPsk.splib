rule client_hello_psk:
    let
        messages = '0'
        binder = '0'
        supported_groups = <$g1, $g2>
        gx = $g1^~x
        psk_ke_mode = <'0', '1'>
        obfuscated_ticket_age = mask(ticket_age_add, $ticket_age)
        identities = <<~ticket, obfuscated_ticket_age>>
        es = Extract(res_psk, '0')
        edi = ExtensionEarlyDataIndication()
        binder_extensions = <
            ExtensionSupportedVersions(),
            ExtensionNamedGroupdList(supported_groups),
            ExtensionKeyShareClientHello(KeyShareEntry($g1, gx)),
            ExtensionPskKeyExchangeModes(psk_ke_mode),
            edi,
            ExtensionPreSharedKeyClientHello(identities, binder)
        >
        binder_message = ClientHello(~nc, '0', $cipher_suites, '0', binder_extensions)
        binder_messages = <messages, binder_message>
        binder = hmac(Expand(Expand(es, <psk_type, 'TLS13pskbinderkey', '0'> , '32'), <'32', '0', '0'> , '32'), h(binder_messages))
        extensions = <
            ExtensionSupportedVersions(),
            ExtensionNamedGroupdList(supported_groups),
            ExtensionKeyShareClientHello(KeyShareEntry($g1, gx)),
            ExtensionPskKeyExchangeModes(psk_ke_mode),
            edi,
            ExtensionPreSharedKeyClientHello(identities, binder)
        >
        message = ClientHello(~nc, '0', $cipher_suites, '0', extensions)
        messages = <messages, message>

        ead_keyc = Expand(Expand(es, <'TLS13clientearlytrafficsecret', <h(messages)>>, '32'), <'TLS13earlyapplicationdatakeyexpansion_key', '0'>, '32')
    in
    [
        Fr(~nc),
        Fr(~x),
        !ClientPSK($C, $S, res_psk, auth_status, <'4',$ticket_lifetime, ticket_age_add, ~ticket,<<'46',$max_early_data_size>> >, psk_type)
    ]
    --[
        C0_PSK(~nc),
        Start(~nc, $C, 'client'),
        RPSK(~nc, $C, 'client', <$S, res_psk, auth_status>),
        Neq(res_psk, '0'),
        DH(~nc, $C, ~x)
    ]->
    [
        ClientState(
            ~nc,
            'C1',
            $C,
            $S,
            res_psk,
            messages,
            ~nc,
            '0',
            $g1,
            supported_groups,
            '0',
            ~x,
            '0',
            gx,
            '0',
            '0',
            psk_ke_mode,
            ~ticket,
            edi,
            es,
            '0',
            '0',
            '0',
            '0',
            '0',
            '0',
            auth_status,
            '0',
            '0',
            '0'
        ),
        F_CachePSK(~nc, $S, res_psk, auth_status, <'4', $ticket_lifetime, ticket_age_add, ~ticket, <<'46',$max_early_data_size>> >,psk_type),
        EarlySendStream(~nc, $C, $S, auth_status, ead_keyc, edi),
        DHExp(~x, ~nc, $C),
        MessageOut(message)
    ]

rule recv_hello_retry_request_psk:
    let
        p_g = $g1
        p_hrr = '0'
        p_psk_ke_mode = <'0', '1'>
        edi = '0'

        hrr = 'hrr'
        supported_groups = <$g1, $g2>

        res_psk = p_res_psk
        auth_status = p_auth_status
        psk_id = ticket

        receivedExtensions = <
            ExtensionSupportedVersions(),
            ExtensionKeyShareHelloRetryRequest($g2)
        >
        receivedMessage = HelloRetryRequest(receivedExtensions)
        messages = <p_messages, receivedMessage>

        obfuscated_ticket_age = mask(ticket_age_add, '1')
        identities = <<ticket, obfuscated_ticket_age>>

        gx = $g2^~new_x

        es = Extract(res_psk, '0')
        binder = '0'
        binder_extensions = <
            ExtensionSupportedVersions(),
            ExtensionNamedGroupdList(supported_groups),
            ExtensionKeyShareClientHello(KeyShareEntry($g2, gx)),
            ExtensionPskKeyExchangeModes(p_psk_ke_mode),
            edi,
            ExtensionPreSharedKeyClientHello(identities, binder)
        >
        binder_message = ClientHello(~new_nc, '0', $cipher_suites, '0', binder_extensions)
        binder_messages = <messages, binder_message>
        binder = hmac(Expand(Expand(es, <psk_type, 'TLS13pskbinderkey', '0'> , '32'), <'32', '0', '0'> , '32'), h(binder_messages))

        extensions = <
            ExtensionSupportedVersions(),
            ExtensionNamedGroupdList(supported_groups),
            ExtensionKeyShareClientHello(KeyShareEntry($g2, gx)),
            ExtensionPskKeyExchangeModes(p_psk_ke_mode),
            edi,
            ExtensionPreSharedKeyClientHello(identities, binder)
        >
        message = ClientHello(~new_nc, '0', $cipher_suites, '0', extensions)
        messages = <messages, message>
    in
    [
        ClientState(
            ~tid,
            'C1',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        F_CachePSK(~tid, $S, p_res_psk, p_auth_status, <'4', $ticket_lifetime, ticket_age_add, ticket,<<'46',$max_early_data_size>> >,psk_type),
        Fr(~new_nc),
        Fr(~new_x),
        DHExp(p_x, ~tid, $C),
        F_MessageIn(receivedMessage)
    ]
    --[
        C1_retry_PSK(~tid),
        Neq($g1, $g2),
        Instance(~tid, $C, 'client'),
        RPSK(~tid, $C, 'client', <$S, p_res_psk, p_auth_status>),
        DeleteDH(~tid, $C, p_x),
        DH(~tid, $C, ~new_x)
    ]->
    [
        MessageOut(message),
        DHExp(~new_x, ~tid, $C),
        ClientState(
            ~tid,
            'C1',
            $C,
            $S,
            res_psk,
            messages,
            ~new_nc,
            p_ns,
            $g2,
            p_sg,
            hrr,
            ~new_x,
            p_y,
            gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            ticket,
            edi,
            es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]

rule recv_server_hello_psk:
    let
        p_psk_ke_mode = <'0', '1'>
        psk_ke_mode = '0'
        extensions = <
            ExtensionSignatureSchemeList($sig_algs),
            <'41', '0'>,
            p_edi
        >
        message = ServerHello(new_ns, '0', $cipher_suite, '0', extensions)
        messages = <p_messages, message>
    in
    [
        ClientState(
            ~tid,
            'C1',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        F_MessageIn(message)
    ]
    --[
        C1_PSK(~tid),
        Instance(~tid, $C, 'client'),
        RNonces(~tid, $C, 'client', <p_nc ,new_ns>)
    ]->
    [
        ClientState(
            ~tid,
            'C2a',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            new_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]

rule recv_server_hello_psk_dhe:
    let
        p_g = $g
        p_psk_ke_mode = <'0', '1'>
        psk_ke_mode = '1'
        gy = p_g^new_y
        gxy = gy^p_g
        receivedExtensions = <
            ExtensionSignatureSchemeList($sig_algs),
            ExtensionKeyShareServerHello(KeyShareEntry(p_g, gy)),
            <'41', '0'>,
            p_edi
        >
        receivedMessage = ServerHello(new_ns, '0', $cipher_suite, '0', receivedExtensions)
        messages = <p_messages, receivedMessage>
    in
    [
        ClientState(
            ~tid,
            'C1',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            ~x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            ~ticket,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        F_MessageIn(receivedMessage)
    ]
    --[
        C1_PSK_DHE(~tid),
        Neq(gy, $g),
        Instance(~tid, $C, 'client'),
        DHChal($g, ~x, new_y, p_gx, gy, gxy),
        RNonces(~tid, $C, 'client', <p_nc, new_ns>)
    ]->
    [
        ClientState(
            ~tid,
            'C2a',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            new_ns,
            p_g,
            p_sg,
            p_hrr,
            ~x,
            p_y,
            p_gx,
            gy,
            gxy,
            psk_ke_mode,
            ~ticket,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]

rule recv_server_auth_psk:
    let
        exp_verify_data = hmac(Expand(Expand(p_hs, <'TLS13serverhandshaketrafficsecret', <h(p_messages)>>, '32'), <'TLS13finished', '0'>, '32'), h(p_messages))

        message = Finished(verify_data)
        messages = <p_messages, message>

        cats = Expand(p_ms, <'TLS13clientapplicationtrafficsecret', <h(messages)>>, '32')
        sats = Expand(p_ms, <'TLS13serverapplicationtrafficsecret', <h(messages)>>, '32')
        app_keys = Expand(sats, <'TLS13applicationdatakeyexpansion_key', '0'>, '32')
        ems = Expand(p_ms, <'TLS13exportermastersecret', <h(messages)>>, '32')
    in
    [
        ClientState(
            ~tid,
            'C2d',
            $C,
            $S,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        F_MessageIn(senc{message}p_hs_keys)
    ]
    --[
        C2d_PSK(~tid),
        Neq(p_psk_ke_mode, 'na'),
        Instance(~tid, $C, 'client'),
        Eq(verify_data, exp_verify_data),
        RMode(~tid, $C, 'client', <p_psk_ke_mode>),
        CIdentity(~tid, $C, 'client', <<$S, p_auth_status>>),
        CHS(~tid, $C, 'client', <p_hs>),
        CNonces(~tid, $C, 'client', <p_nc, p_ns>),
        CTranscript(~tid, $C, 'client', <messages>)
    ]->
    [
        ClientState(
            ~tid,
            'C3',
            $C,
            $S,
            p_res_psk,
            messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            cats,
            sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            ems,
            p_rms,
            p_cert_req
        ),
        RecvStream(~tid, $C, $S, p_auth_status, app_keys)
    ]