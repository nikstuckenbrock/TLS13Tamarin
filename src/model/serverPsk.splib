rule recv_client_hello_psk:
    let
        binder = '0'
        supported_groups = <$g1, $g2>
        gx = $new_g^x
        clientRandom = new_nc
        psk_ke_mode = <PskKeyExchangeModePskKe(), PskKeyExchangeModePskDheKe()>
        ticket = ~ticket
        ticket_age_add = ~ticket_age_add
        identities = <<ticket, obfuscated_ticket_age>>
        psk_id = ticket
        ticket_age = unmask(obfuscated_ticket_age, ticket_age_add)
        binder_extensions = <
            ExtensionSupportedVersions(),
            ExtensionNamedGroupdList(supported_groups),
            ExtensionKeyShare(KeyShareEntry($new_g, gx)),
            ExtensionPskKeyExchangeModes(psk_ke_mode),
            new_edi,
            ExtensionPreSharedKeyClientHello(identities, binder)
        >
        binder_message = ClientHello(clientRandom, '0', $cipher_suites, '0', binder_extensions)
        binder_messages = <p_messages, binder_message>
        res_psk = psk_res_psk
        es = Extract(res_psk, '0')
        binder_check = hmac(Expand(Expand(es, <psk_type, 'TLS13pskbinderkey', '0'> , '32'), <'32', '0', '0'> , '32'), h(binder_messages))
        extensions = <
            ExtensionSupportedVersions(),
            ExtensionNamedGroupdList(supported_groups),
            ExtensionKeyShare(KeyShareEntry($new_g, gx)),
            ExtensionPskKeyExchangeModes(psk_ke_mode),
            new_edi,
            ExtensionPreSharedKeyClientHello(identities, binder_in)
        >
        receivedMessage = ClientHello(clientRandom, '0', $cipher_suites, '0', extensions)
        messages = <p_messages, receivedMessage>

        ead_keyc = Expand(Expand(es, <'TLS13clientearlytrafficsecret', <h(messages)>> , '32'), <'TLS13earlyapplicationdatakeyexpansion_key', '0'> , '32')
    in
    [
        ServerState(
            ~tid,
            'S0',
            $S,
            $C,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        F_MessageIn(receivedMessage),
        Fr(~ns),
        !ServerPSK($S, $C, psk_res_psk, psk_auth_status, <'4', $ticket_lifetime, ticket_age_add, ticket, <<'46', $max_early_data_size>>>, psk_type)
    ]
    --[
        S0_PSK(~tid),
        Neq($g1, $g2),
        Eq(unmask(obfuscated_ticket_age, ticket_age_add), '1'),
        Eq(binder_check, binder_in),
        RPSK(~tid, $S, 'server', <$C, psk_res_psk, psk_auth_status>),
        Neq(psk_res_psk, '0')
    ]->
    [
        ServerState(
            ~tid,
            'S1',
            $S,
            $C,
            res_psk,
            messages,
            clientRandom,
            ~ns,
            $new_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            gx,
            p_gy,
            p_gxy,
            psk_ke_mode,
            psk_id,
            new_edi,
            es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            psk_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        EarlyRecvStream(~tid, $S, $C, psk_auth_status, ead_keyc, new_edi)
    ]

rule server_hello_psk:
    let
        es = Extract(p_res_psk, '0')
        p_psk_ke_mode = <'0', '1'>
        psk_ke_mode = '0'
        extensions = <
            ExtensionSignatureSchemeList($sig_algs),
            <'41', '0'>,
            p_edi
        >
        message = ServerHello(~ns, '0', $cipher_suite, '0', extensions)
        messages = <p_messages, message>
    in
    [
        ServerState(
            ~tid,
            'S1',
            $S,
            $C,
            p_res_psk,
            p_messages,
            p_nc,
            ~ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            ~ticket,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        Fr(~y_ignored),
    ]
    --[
        S1_PSK(~tid),
        Instance(~tid, $S, 'server'),
        RNonces(~tid, $S, 'server', <p_nc, ~ns>),
        DH(~tid, $S, ~y_ignored)
    ]->
    [
        ServerState(
            ~tid,
            'S2a',
            $S,
            $C,
            p_res_psk,
            messages,
            p_nc,
            ~ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            ~y_ignored,
            p_gx,
            p_gy,
            p_gxy,
            psk_ke_mode,
            ~ticket,
            p_edi,
            es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        DHExp(~y_ignored, ~tid, $S),
        !DHEx(~y_ignored, ~tid, $S),
        MessageOut(message)
    ]

rule server_hello_psk_dhe:
    let
        p_g = $g
        p_gx = p_g^some_x
        p_psk_ke_mode = <'0', '1'>
        gy = p_g^~y
        gxy = p_gx^~y
        psk_ke_mode = '1'
        es = Extract(p_res_psk, '0')
        extensions = <
            ExtensionSignatureSchemeList($sig_algs),
            ExtensionKeyShare(KeyShareEntry(p_g, gy)),
            <'41', '0'>,
            p_edi
        >
        message = ServerHello(~ns, '0', $cipher_suite, '0', extensions)
        messages = <p_messages, message>
    in
    [
        ServerState(
            ~tid,
            'S1',
            $S,
            $C,
            p_res_psk,
            p_messages,
            p_nc,
            ~ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            ~ticket,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        Fr(~y)
    ]
    --[
        S1_PSK_DHE(~tid),
        Neq(p_gx, p_g),
        Neq(p_x, inv(~y)),
        Instance(~tid, $S, 'server'),
        DHChal(p_g, some_x, ~y, p_gx, gy, gxy),
        RNonces(~tid, $S, 'server', <p_nc, ~ns>),
        DH(~tid, $S, ~y)
    ]->
    [
        ServerState(
            ~tid,
            'S2a',
            $S,
            $C,
            p_res_psk,
            messages,
            p_nc,
            ~ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            ~y,
            p_gx,
            gy,
            gxy,
            psk_ke_mode,
            ~ticket,
            p_edi,
            es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        ),
        DHExp(~y, ~tid, $S),
        !DHEx(~y, ~tid, $S),
        MessageOut(message)
    ]

rule server_auth_psk:
    let
        verify_data = hmac(Expand(Expand(p_hs, <'TLS13serverhandshaketrafficsecret', <h(p_messages)>>, '32'), <'TLS13finished', '0'>, '32'), h(p_messages))
        message = Finished(verify_data)
        messages = <p_messages, message>

        clientApplicationTrafficSecret = Expand(p_ms, <'TLS13clientapplicationtrafficsecret', <h(messages)>>, '32')
        serverApplicationTrafficSecret = Expand(p_ms, <'TLS13serverapplicationtrafficsecret', <h(messages)>>, '32')
        serverApplicationTrafficKey = Expand(serverApplicationTrafficSecret, <'TLS13applicationdatakeyexpansion_key', '0'>, '32')
        earlyMasterSecret = Expand(p_ms, <'TLS13exportermastersecret', <h(messages)>>, '32')
    in
    [
        ServerState(
            ~tid,
            'S2d',
            $S,
            $C,
            p_res_psk,
            p_messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            p_cats,
            p_sats,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            p_ems,
            p_rms,
            p_cert_req
        )
    ]
    --[
        S2d_PSK(~tid),
        Neq(p_psk_ke_mode, 'na'),
        Instance(~tid, $S, 'server'),
        RTranscript(~tid, $S, 'server', <messages>)
    ]->
    [
        ServerState(
            ~tid,
            'S3',
            $S,
            $C,
            p_res_psk,
            messages,
            p_nc,
            p_ns,
            p_g,
            p_sg,
            p_hrr,
            p_x,
            p_y,
            p_gx,
            p_gy,
            p_gxy,
            p_psk_ke_mode,
            p_psk_id,
            p_edi,
            p_es,
            p_hs,
            p_ms,
            clientApplicationTrafficSecret,
            serverApplicationTrafficSecret,
            p_hs_keyc,
            p_hs_keys,
            p_auth_status,
            earlyMasterSecret,
            p_rms,
            p_cert_req
        ),
        SendStream(~tid, $S, $C, p_auth_status, serverApplicationTrafficKey),
        MessageOut(senc{message}p_hs_keys)
    ]